;
;	PROGRAM, DESIGNED FOR THE INTRODUCTION TO MINICOMPUTERS COURSE,
;	TO SHOW HOW AN INSTRUCTION IS EXECUTED IN THE HART OF THE CPU
;	OF A PDP-8 LIKE PROCESSOR
;	WRITTEN BY JAN POSTHUMA, TRAINING UTRECHT HOLLAND
;	DATE 1 NOVEMBER 1978
;	PRELIMINARY RELEASE
;	TRANSLATED INTO ENGLISH BY DICK BIESBOER, TRAINING UTRECHT
;	DATE 7 JANUARY 1980
;	THIS SIMULATION PROCESSOR IS DESCRIBED IN THE MODULE
;	"CENTRAL PROCESSOR" IN PART 5 OF THE INTRODUCTION TO
;	MINICOMPUTERS COURSE.
;
;	ADAPTED FOR VT100 AND PARTLY REWRITE BY ED GROENENBERG, MAR-2021
;
;	TO ASSEMBLE INTO : MAC CPU101
;	TO LINK INTRO    : LINK CPU101
;
	.TITLE	INTRO
;
	.MCALL EXIT$S, QIOW$S, MRKT$S, WTSE$S
;
;	SOME MACROS TO SPECIFY ASCII FIELDS
;	THE FIRST MACRO IS TO DRAW A STRING OF CHARACTERS
;	TO THE RIGHT;
;
	.MACRO	.STRING,.NUM,.CHAR
	.REPT	.NUM
	.BYTE	.CHAR
	.ENDR
	.ENDM
;
;	MACRO TO POSITION.
;
	.MACRO	.POS,.LH,.LL,.CH,.CL	;POSITION MACRO
	.BYTE	ESC,'[			;ESCAPE[rr;ccH
	.BYTE	.LH+'0,.LL+'0,';
	.BYTE	.CH+'0,.CL+'0,'H
	.ENDM
;
;	THIS MACRO DRAWS A REGISTER.
;
	.MACRO	.REG,.UD,.LEFT,.RIGHT
	.STRING	16.,.UD
	.STRING	16.,BS
	.BYTE	LF,.LEFT,BS,LF
	.STRING	16.,.UD
	.BYTE	BS,ESC,'[,'1,'A		; MOVE UP
	.BYTE	.RIGHT
	.ENDM
;
;	MACRO TO DRAW A STRING DOWNWARDS.
;
	.MACRO	.DOWN,.NUN,.CHR
	.REPT	.NUN
	.BYTE	.CHR,LF,BS
	.ENDR
	.ENDM
;
;	MACRO TO DRAW A STRING UPWARDS.
;
	.MACRO	.UP,.NM,.CH
	.REPT	.NM
	.BYTE	.CH,BS,ESC,'[,'1,'A
	.ENDR
	.ENDM
;
;	MACRO TO DRAW A STRING TO THE LEFT.
	.MACRO	.LEF,.NUUM,.CHAAR
	.REPT	.NUUM
	.BYTE	.CHAAR,BS,BS
	.ENDR
	.ENDM
;
;	MACRO TO CLEAN A LINE.
;
	.MACRO	.CLIN
	.BYTE	ESC,'[,'K
	.ENDM
;
;	DIRECT ASSIGNMENTS
;
	BELL=007
	BS=010
	LF=012
	CR=015
	ESC=033
	SPACE=040
	MEMTOP=157		; 157 OCTAL ADRESSES.
;
;	MICRO INSTRUCTIONS
;
	BRTOME=1
	BRTOAL=2
	ACTOAL=3
	ALTOAC=4
	ACTOBR=5
	BRTOIR=6
	IRTODC=7
	IRTOPC=8.
	PCTOAR=9.
	ARTOME=10.
	IRTOAR=11.
	PCPLON=12.
	METOBR=13.
	MMREAD=14.
	MMWRIT=15.
	ACCUCL=16.
	SERVIC=17.
	GOFETC=18.
	GOEXEC=19.
	EXEALU=20.
	BRCLME=21.
	BRCLAL=22.
	ACCLAL=23.
	ALCLAC=24.
	ACCLBR=25.
	BRCLIR=26.
	IRCLDC=27.
	IRCLPC=28.
	PCCLAR=29.
	ARCLME=30.
	IRCLAR=31.
	PCCLON=32.
	MECLBR=33.
	MMCLAD=34.
	MMCLIT=35.
	ACCLCL=36.
	ALTOBR=37.
	ALCLBR=38.
	GOHALT=39.
	BRTOAR=40.
	BRCLAR=41.
	MUSKIP=42.

START:	CLR	GRQENB		;DISABLE GRAPHIC DELAY AT START.
RSTART:	JSR	R5,OUT		;WELCOME MESSAGE
RST1:	.WORD	CMES01,0
	JSR	R5,WAIT		;WAIT 3 SECONDS
	.WORD	0,150.
RST1A:	JSR	R5,SHOMEM	;SHOW MEMORY CONTENTS.
	.WORD	1		;CLEAN SCREEN
RST1B:	JSR	R5,OUT		;REQUEST ACTION
	.WORD	CMES02,0	
	JSR	R5,IN		;ASK FOR INPUT
	.WORD	1
RST1C:	CMPB	GENBUF,#'H	;HELP?
	BEQ	RST3
	CMPB	GENBUF,#'h
	BEQ	RST3
	CMPB	GENBUF,#'Q	;EXIT?
	BEQ	RST4
	CMPB	GENBUF,#'q
	BEQ	RST4
	CMPB	GENBUF,#'E	;EXECUTE?
	BEQ	RST5
	CMPB	GENBUF,#'e
	BEQ	RST5
	CMPB	GENBUF,#'L	;LOAD?
	BEQ	RST1D
	CMPB	GENBUF,#'l
	BNE	RST1C
RST1D:	JMP	RST9

RST3:	JSR	R5,OUT		;DISPLAY HELP
	.WORD	CMES22,0
	JSR	R5,IN
	.WORD	1		;WAIT UNTIL READ
	JMP	RST1A		;RESTART AGAIN

RST4:	JSR	R5,OUT		;DISPLAY POWER OFF.
	.WORD	CMES23,0
;	JSR	R5,WAIT		;WAIT 2 SECONDS
;	.WORD	0,100.
	EXIT$S			;STOP IT.

RST5:	JSR	R5,OUT		;NORMAL OR SPECIAL?
	.WORD	CMES03,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'N	;NORMAL?
	BEQ	RST6
	CMPB	GENBUF,#'n
	BEQ	RST6
	CMPB	GENBUF,#'Y	;SPECIAL?
	BEQ	RST5A
	CMPB	GENBUF,#'y
	BNE	RST5
RST5A:	JMP	RST17

RST6:	JSR	R5,OUT		;ASK FOR START ADDRESS.
	.WORD	CMES12,0
	JSR	R5,IN
	.WORD	4		;FORMATTED INPUT.
	MOV	IOSTAT+2,RST6A+2;LENGTH
	BEQ	RST6
	JSR	R5,COCBIN	;CONVERT OCTAL TO BINARY.
RST6A:	.WORD	GENBUF,4,0
	TST	COCBA		;FALSE?
	BNE	RST6		;YES!!!
	MOV	RST6A+4,IPC	;TO PC
;
;	PROGRAM IS NOW LOADED.
;	GRAPHICS CAN BE PRINTED.
;	MEMORY AND PROGRAM COUNTER ARE DISPLAYED.
;
	JSR	R5,OUT
	.WORD	LAYOUT,0
	MOV	IMEMVL,R3	;LOWER MEMORY BOUNDARY TO R3.
	MOV	#1,R1		;FIRST POSITION IN R1.
	CLR	TMPY
	MOV	#'0,RST8+4
RST7:	MOV	R1,RST8		;REUSE RST8 AS TEMP VAR
	CMP	R1,#10.
	BNE	RST7A
	MOVB	#'1,RST8+4
	MOV	#10.,TMPY
RST7A:	CMP	R1,#20.
	BNE	RST7B
	MOVB	#'2,RST8+4
	MOV	#20.,TMPY
RST7B:	SUB	TMPY,RST8
	ADD	#'0,RST8
	MOVB	RST8,RST8+5	;SET ROW POSITION.
	MOV	R3,R2
	ASL	R2
	ADD	#IMEM,R2	;MAKE REAL ADDRESS.
	MOV	R2,RST8
	MOV	R3,IAR		;IAR TO SHOW ADDRESS.
	JSR	R5,DISMEM	;DISPLAY MEMORY.
RST8:	.WORD	0
	.POS	0,1,7,2
	INC	R1		;INCREMENT POSITION SCREEN.
	INC	R3		;GO TO NEXT POSITION.
	CMP	R3,IMEMVH	;END OF MEMORY BLOCK?
	BNE	RST7
	JSR	R5,DISREG	;DISPLAY ACCUMULATOR
	.WORD	IAC
	.POS	1,1,0,5
	JSR	R5,DISCON	;DISPLAY CONDITION REGISTER
	JSR	R5,DISREG	;DISPLAY PROGRAM COUNTER
	.WORD	IPC
	.POS	1,7,5,2
	CLR	IOST		;OPEN INPUT FOR KEYBOARD
	MOV	#MFETCH,MICPC	;PUT MICRO P.C. ON START OF MICROCODE.
	MOV	#MICENT,R5	;JUMP IN THE MIDDLE OF SUBROUTINE.
	MOV	R5,-(SP)
	JMP	TIMS2		;WAIT FOR USER SPACE.
;
;	PROGRAM LOAD ROUTINE.
;
RST9:	JSR	R5,OUT		;ASK FOR LOAD ADDRESS.
	.WORD	CMES08,0
	MOV	#1,GENBF	;MARK FLAG FOR FIRST TIME.
	JSR	R5,IN
	.WORD	4
	MOV	IOSTAT+2,RST9A+2;LENGTH.
	BEQ	RST9
	JSR	R5,COCBIN	;CONVERT OCTAL TO BINARY
RST9A:	.WORD	GENBUF,4,0
	TST	COCBA
	BNE	RST9		;FALSE OC'S.
	MOV	RST9A+4,IAR	;PUT IN ADDRESS REGISTER.
RST10: TST	GENBF		;FIRST TIME?
	BEQ	RST12		;NO
	JSR	R5,OUT
	.WORD	CMES10,0
RST11:	JSR	R5,CBINOC	;CONVERT BINARY TO OCTAL.
RST11A:	.WORD	IAR,0,0
	CLR	GENBF		;MARK FLAG FOR FIRST TIME.
	MOVB	#ESC,GENBUF	;CLEAR LINE FIRST BEFORE WRITING
	MOVB	#'[,GENBUF+1
	MOVB	#'K,GENBUF+2
	MOVB	RST11A+2,GENBUF+3;OCTAL VALUE.
	MOVB	RST11A+3,GENBUF+4
	MOVB	RST11A+4,GENBUF+5
	MOVB	RST11A+5,GENBUF+6
	MOVB	#SPACE,GENBUF+7	;ADD SPACES.
	MOVB	#SPACE,GENBUF+8.
	JSR	R5,OUT
	.WORD	GENBUF,9.
	JSR	R5,IN
	.WORD	4
	CMP	GENBUF,#"EN	;LAST?
	BEQ	RST11B
	CMP	GENBUF,#"en
	BNE	RST13
RST11B:	JMP	RST1B
RST12:	JSR	R5,OUT		;CURSOR IN RIGHT POSITION 23.,1
	.WORD	CMES29,0
	BR	RST11
RST13:	MOV	IOSTAT+2,RST13A+2;LENGTH.
	BEQ	RST16
	JSR	R5,COCBIN	;CONVERT OCTAL TO BINARY.
RST13A:	.WORD	GENBUF,4,0
	TST	COCBA		;FALSE?
	BNE	RST10
	CMP	IAR,#MEMTOP	;NORMAL AREA OF MEMORY?
	BLOS	RST14		;NOT EXISTING.
	JSR	R5,OUT		;SHOW ERROR
	.WORD	CMES17,0
	JSR	R5,WAIT
	.WORD	0,50.		; WAIT A SECOND.
	JMP	RST9
RST14:	MOV	IAR,R0		;FIRST CONVERT
	ASL	R0		;MAKE BYTE ADDRESS
	ADD	#IMEM,R0	;TO REAL MEMORY.
	MOV	RST13A+4,(R0)	;STORE IN MEMORY.
	JSR	R5,SHOMEM	;SHOW MEMORY AGAIN.
	.WORD	-1.		;NO CLEAN SCREEN, AND ONLY ONE WORD.
RST15:	INC	IAR		;GO TO THE NEXT.
	BIC	#170000,IAR	;REMOVE HIGHEST BITS.
	JMP	RST10		;AND READ THE NEXT.

RST16:	CMPB	#CR,IOSTAT+1	;LOOK AT TERMINATING CHARACTER.
	BEQ	RST15
	CMPB	#ESC,IOSTAT+1	;IS IT AN ESCAPE?????? THEN BACK.
	BNE	RST10		;NO INCREMENT.
	DEC	IAR		;DECREMENT THE COUNTER.
	BIC	#170000,IAR
	JMP	RST10
;
;	SPECIAL MODE OF EXECUTION.
;
RST17:	MOV	IMEMVL,OLDVL	;KEEP THE OLD BOUNDARIES
	MOV	IMEMVH,OLDVH
	JSR	R5,OUT		;ASK FOR VISIBLE START ADDRESS.
	.WORD	CMES13,0
	JSR	R5,IN
	.WORD	4
	MOV	IOSTAT+2,RST17A+2;LENGTH.
	BEQ	RST17
	JSR	R5,COCBIN	;CONVERT OCTAL TO BINARY.
RST17A:	.WORD	GENBUF,4,0
	TST	COCBA		;FALSE OC'S?
	BNE	RST17
	CMP	RST17A+4,#133	;HIGHEST POSSIBLE VISIBLE START ADDRESS?
	BHI	RST17
	CMP	RST17A+4,IMEMVL	;CHANGE IN VISIBLE PART?
	BEQ	RST18		;NO, THEN NO SCREEN REFRESH.
	MOV	RST17A+4,IMEMVL	;FIRST CHANGE THE BOUNDARY.
	MOV	IMEMVL,IMEMVH	;ALSO HIGH BOUNDARY.
	ADD	#21.,IMEMVH
	JSR	R5,SHOMEM	;YES, REFRESH SCREEN.
	.WORD	-2.		;NO, CLEAN AND ONLY DOTS.
RST18:	MOV	RST17A+4,IMEMVL	;LOAD LOWER MEMORY BOUNDARY.
	MOV	IMEMVL,IMEMVH
	ADD	#21.,IMEMVH	;HIGHEST POSITION.
RST19:	JSR	R5,OUT		;REG.DISPLAY OCTAL OR BINARY?
	.WORD	CMES07,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'O	;OCTAL?
	BEQ	RST20
	CMPB	GENBUF,#'o	;OCTAL?
	BEQ	RST20
	CMPB	GENBUF,#'B	;BINARY?
	BEQ	RST21
	CMPB	GENBUF,#'b	;BINARY?
	BEQ	RST21
	BR	RST19		;NOT KNOWN.
RST20:	CLR	OCBINR		;SET OCTAL
	BR	RST22
RST21:	MOV	#1,OCBINR	;SET BINARY.
RST22:	MOV	#-1.,IBR	;FLAG FOR TWO PAUSE QUESTIONS.
	JSR	R5,OUT
	.WORD	CMES05,0
RST23:	JSR	R5,OUT		;WHICH PAUSE MODE?
	.WORD	CMES04,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'N
	BEQ	RST24		;NOWAIT.
	CMPB	GENBUF,#'n
	BEQ	RST24
	CMPB	GENBUF,#'A
	BEQ	RST25		;AUTO STEP.
	CMPB	GENBUF,#'a
	BEQ	RST25
	CMPB	GENBUF,#'U
	BEQ	RST27		;USER STEP.
	CMPB	GENBUF,#'u
	BEQ	RST27
	BR	RST23
RST24:	CLR	SEQMOD		;MAKE NOWAIT.
	BR	RST28
RST25:	MOV	#1,SEQMOD	;MAKE AUTO STEP
	JSR	R5,OUT		;ASK FOR NUMBER OF TICKS.
	.WORD	CMES14,0
	JSR	R5,IN
	.WORD	4
	MOV	IOSTAT+2,RST26+2
	BEQ	RST25
	JSR	R5,COCBIN	;CONVERT TO BINARY.
RST26:	.WORD	GENBUF,4,0
	TST	COCBA		;FALSE?
	BNE	RST25
	MOV	RST26+4,SEQMOD+2;NUMBER OF TICKS.
	BR	RST28
RST27:	MOV	#2,SEQMOD	;MAKE USER STEP
RST28:	INC	IBR
	BNE	RST29
	MOV	SEQMOD,ISQMOD	;FOR INSTRUCTIONS
	MOV	SEQMOD+2,ISQMOD+2;TRANSFER TICK.
	JSR	R5,OUT		;PAUSE BETWEEN INSTRUCTIONS?
	.WORD	CMES06,0
	JMP	RST23		;GO BACK.
RST29:	JSR	R5,OUT		;ASK FOR SUBTITLES.
	.WORD	CMES20,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'Y	;YES.
	BEQ	RST31
	CMPB	GENBUF,#'y	;YES.
	BEQ	RST31
	CMPB	GENBUF,#'N	;NO.
	BEQ	RST30
	CMPB	GENBUF,#'n	;NO.
	BNE	RST29		;NOT DONE WELL.
RST30:	CLR	MESENB		;DISABLE SUBTITLES.
	BR	RST31A		;BACK TO SATISFIED?
RST31:	MOV	#1,MESENB	;YES SUBTITLES.
RST31A:	JSR	R5,OUT		;ASK FOR DRAWING LINES.
	.WORD	CMES21,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'Y	;YES
	BEQ	RST33
	CMPB	GENBUF,#'y
	BEQ	RST33
	CMPB	GENBUF,#'N	;NO
	BEQ	RST32
	CMPB	GENBUF,#'n
	BNE	RST31A
RST32:	CLR	GRENB		;DISABLE LINE GRAPHICS
	JMP	RST38
RST33:	MOV	#1,GRENB	;ENABLE GRAPHICS
	BR	RST35
RST34:	CLR	GRQMOD		;NO DELAY
	JMP	RST38
RST35:	JSR	R5,OUT		;ASK GRAPHICS DELAY
	.WORD	CMES19,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'N	;NO DELAY?
	BEQ	RST34
	CMPB	GENBUF,#'n
	BEQ	RST34
	CMPB	GENBUF,#'Y	;DELAY?
	BEQ	RST35A
	CMPB	GENBUF,#'y
	BNE	RST35		;ASK AGAIN
RST35A:	MOV	#1,GRQMOD	;MAKE IT DELAY MODE.
RST36:	JSR	R5,OUT
	.WORD	CMES14,0
	JSR	R5,IN
	.WORD	4
	MOV	IOSTAT+2,RST37+2;GET LENGTH.
	BEQ	RST36		;NO DATA?
	JSR	R5,COCBIN	;CONVERT TO BINARY
RST37:	.WORD	GENBUF,4,0
	TST	COCBA		;FALSE CONVERSION?
	BNE	RST36		;YES.
	MOV	RST37+4,GRQMOD+2;SAVE NUMBER OF TICKS.
;
;	ARE YOU SATISFIED NOW?
;
RST38:	JSR	R5,OUT		;SATISFIED?
	.WORD	CMES09,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'Y	;YES?
	BEQ	RST39
	CMPB	GENBUF,#'y
	BNE	RST40
RST39:	JMP	RST6		;YES.
RST40:	CMPB	GENBUF,#'N	;NO?
	BEQ	RST43
	CMPB	GENBUF,#'n	;NO.
	BEQ	RST43
	CMPB	GENBUF,#'Q	;QUIT?
	BEQ	RST42
RTS41:	CMPB	GENBUF,#'q
	BNE	RST38
RST42:	JMP	RST4
RST43:	JMP	RST1B		;BACK
;
;
;	THE NEXT PART IS THE
;	M I C R O   C O D E   I N T E R P R E T E R
;	............................................
;
; MICRO INSTRUCTION LAYOUT :
;
;	BYTE 0 : MICRO INSTRUCTION ACTION.
;	BYTE 1 : MICRO JUMP DATA
;
;		THIS ONE HAS THE FOLLOWING POSSIBILITIES :
;
;		000	GO TO NEXT INSTRUCTION.
;		200	UNCONDITIONAL JUMP.
;			GO TO MICROADDRESS SHOWN BY NEXT MICRO-WORD.
;		201	JUMP ACCORDING TO INSTRUCTION COMPARED TO
;			EXECUTE ADDRESS TABLE.
;		202	GO TO SERVICE STATE.
;		203	SKIP NEXT MICROWORD IF CONDZE FITS SKIP COMBINATION.
;		204	EXAMINE RUN STATE DURING HALT CONDITION.
;
;
;	MICRO PROGRAM COUNTER.
;
MICENT:	MOV	@MICPC,R0	;TAKE MICROINSTRUCTION.
	DEC	R0		;CHANGE TO INDEX.
	ASL	R0		;CHANGE TO BYTE ADDRESS.
	BIC	#177400,R0	;CLEAR HIGH BYTE.
	TST	MESENB		;ASKED FOR SUBTITLES?
	BEQ	MIC1A		;NO.
	MOV	COMTAB(R0),MIC1	;PRINT MESSAGE
	CLR	GRQENB		;DISABLE DELAY OF GRAPHICS.
	JSR	R5,OUT		;PRINT MESSAGE.
MIC1:	.WORD	0,0
	JSR	R5,OUT
	.WORD	MICA,2		;MOVE CURSOR 1 UP
MIC1A:	MOV	GRPTAB(R0),MIC2	;GRAPHICS TABLE
	TST	GRENB		;GRAPHIC LINES WANTED?
	BEQ	MIC2A
	INC	GRQENB		;ENABLE GRAPHICS DELAY.
	JSR	R5,OUT		;PRINT GRAPHICS.
MIC2:	.WORD	0,0
MIC2A:	CLR	GRQENB		;DISABLE DELAY.
	JSR	R5,@ACTTAB(R0)	;DO PROPER ACTION.
	JSR	R5,TIMSEQ	;PAUSE.
MIC3:	MOV	@MICPC,R1	;GET MICRO INSTR.
	BMI	MIC4		;SPECIAL JUMP.
	ADD	#2,MICPC	;GO TO NEXT MICRO WORD.
	BR	MICENT		;RETURN.
;
;		ROUTINE FOR CONDITIONAL MICRO JUMPS
;
MIC4:	MOV	MICPC,R0
	MOVB	1(R0),R1
	CMPB	#200,R1
	BEQ	MIC40		;UNCONDITIONAL JUMP
	CMPB	#201,R1		;COMPARE JUMPBYTE.
	BEQ	MIC41		;EXECUTE JUMP
	CMPB	#202,R1
	BEQ	MIC42		;GO TO SERVICE.
	CMPB	#203,R1
	BEQ	MIC43		;SKIP JUMP?
	CMPB	#204,R1
	BEQ	MIC44		;EXAMINE HALT.
	IOT			;PROGRAM ERROR.
;
;	WRONG MICROCODE IN MICRO ROM!!!!!!
;
;	JUMP ACCORDING TO EXECUTE TABLE.
;
MIC40:	ADD	#2,MICPC	;GO TO NEXT MICRO ADDRESS.
	MOV	@MICPC,MICPC	;LOAD JUMP ADDRESS.
	JMP	MICENT
MIC41:	MOV	IINDEX,R1	;PUT INSTRUCTION INDEX IN R1
	MOV	MEXTAB(R1),MICPC;JUMP TO INDEX
	JMP	MICENT		;TO ENTRY.
MIC42:	MOV	#MSERVC,MICPC	;GO TO SERVICE.
	JMP	MICENT		;BACK TO ENTRY.
MIC43:	MOV	CONDZE,R0	;SKIP CONDITION?
	BIT	#1,R0		;ZERO BIT SET?
	BNE	MIC43B		;YES.
	BIT	#2,R0		;MINUS BIT SET
	BNE	MIC43C		;YES.
;		IAL APPEARS TO BE POSITIVE
	CMP	#30,IINDEX	;SIP INSTRUCTION?
	BNE	MIC43A		;NO SKIP
MIC43D:	TST	MESENB		;ASKED FOR SUBTITLES?
	BEQ	MIC43E		;NO.
	JSR	R5,OUT		;YES !
	.WORD	CMES27,0
MIC43E:	ADD	#2,MICPC	;TAKE JUMP ADDRESS.
	MOV	@MICPC,MICPC	;JUMP BACK TO MICPC
	JMP	MICENT		;ENTRY
;
MIC43A:	TST	MESENB		;ASKED FOR SUBTITLES?
	BEQ	MIC43F		;NO
	JSR	R5,OUT		;NO!
	.WORD	CMES28,0
MIC43F:	ADD	#4,MICPC	;NO SKIP, JUMP OVER.
	JMP	MICENT		;NO ENTRY.
MIC43C:	CMP	#26,IINDEX	;SIM INSTRUCTION?
	BEQ	MIC43D
	BR	MIC43A
MIC43B:	CMP	#24,IINDEX	;SIZ INSTRUCTION?
	BEQ	MIC43D		;YES SKIP IS OK.
	CMP	#2,IINDEX	;INCREMENT SKIP IF ZERO.
	BEQ	MIC43D		;YES, SKIP!
	BR	MIC43A		;NOSKIP.
MIC44:	MOV	#MFETCH,MICPC	;GO TO START.
	JMP	MICENT
;
;	ACTION PROGRAMS
;
;	CALL WITH JSR R5,ACTXX
;	THESE ROUTINES SO THE MICRO ACTIONS.
;	THEY ALSO SHOW THE CHANGED VALUES IN REGITER OR MEMORY.
;
;..........................................................
;
;	BRTOME - BUFFER TO MEMORY.
;
ACT01:	RTS	R5		;NO ACTION.
;
;	BRTOAL	- BUFFER REGISTER TO ARITHMETIC UNIT.
;
ACT02:	MOV	IBR,IALB	;EXECUTE
	RTS	R5
;
;	ACTOAL - ACCUMULATOR TO ARITHMETIC UNIT.
;
ACT03:	MOV	IAC,IALA	;EXECUTE
	RTS	R5
;
;	ALTOCA - ARITHMETIC UNIT TO ACCUMULATOR
;
ACT04:	MOV	IAL,IAC		;EXECUTE
	JSR	R5,DISREG
	.WORD	IAC
	.POS	1,1,0,5
	RTS	R5
;
;	ACTOBR - ACCUMULATOR TO BUFFER REGISTER.
;
ACT05:	MOV	IAC,IBR		;EXECUTE.
	JSR	R5,DISREG
	.WORD	IBR
	.POS	0,4,0,8.
	RTS	R5
;
;	BRTOIR - BUFFER REGISTER TO INSTRUCTION REGISTER.
;
ACT06:	MOV	IBR,IIR		;EXECUTE.
	JSR	R5,DISREG
	.WORD	IIR
	.POS	1,1,3,3
	RTS	R5
;
;	IRTODC - INSTRUCTION REGISTER TO CONVERTOR.
;
ACT07:	MOV	IIR,R0
	BIC	#170000,R0	;INSTRUCTION IN R0
	CMP	R0,#7000	;7-INSTRUCTION?
	BHIS	ACT7A
	BIC	#777,R0		;CLEAR ADDRESS.
ACT7A:	MOV	#INSTAB,R2	;POINTER TO R2.
	CLR	R1		;INDEX TO 0
ACT7B:	MOV	DIMTAB(R1),R3
	MOV	R3,ACT7C	;TRANSFER ADDRESS.
	ADD	#2,R1		;INCREMENT INDEX
	TST	GRENB		;GRAPHICS ASKED?
	BEQ	ACT7D
	JSR	R5,OUT
ACT7C:	.WORD	0,0
ACT7D:	CMP	R0,(R2)+	;KNOWN INSTRUCTION?
	BEQ	ACT7E		;YES.
	CMP	R2,#INSTAE	;END OF INSTRUCTION TABLE?
	BNE	ACT7B		;NOT YES.
	MOV	#ERR1,R5
	RTS	R5		;JUMP TO ERROR ROUTINE.
;				INSTRUCTION NOT FOUND
ACT7E:	TST	GRENB		;GRAPHICS ASKED?
	BNE	ACT7G
	MOV	ACT7C,ACT7F	;TRANSFER CORRECT INSTRUCTION ADDRESS.
	JSR	R5,OUT
ACT7F:	.WORD	0,8.
ACT7G:	SUB	#INSTAB+2,R2	;MAKE INDEX ADDRESS OF R2.
	MOV	R2,IINDEX	;SAVE FOR MICRO EXECUTE JUMP.
	ADD	#INTTAB,R2	;COMMENT
	MOV	(R2),R2		;PICK UP THE ADDRESS.
	MOV	(R2)+,ACT7I+2	;LENGTH.
	MOV	R2,ACT7I	;ADDRESS.
	TST	MESENB		;ASKED FOR SUBTITLES?
	BNE	ACT7H		;YES
	RTS	R5
ACT7H:	JSR	R5,OUT		;COMMENT INSTRUCTION.
ACT7I:	.WORD	0,0
	RTS	R5
;
;	IRTOPC - INSTRUCTION REGISTER TO PROGRAM COUNTER.
;
ACT08:	MOV	IIR,R0
	BIC	#177000,R0	;ONLY THE ADDRESS
	MOV	R0,IPC
	JSR	R5,DISREG
	.WORD	IPC
	.POS	1,7,5,2
	RTS	R5
;
;	PCTOAR - PROGRAM COUNTER TO ADDRESS REGISTER.
;
ACT09:	MOV	IPC,IAR		;EXECUTE.
	JSR	R5,DISREG
	.WORD	IAR
	.POS	0,6,5,2
	RTS	R5
;
;	ARTOME - ADDRESS REGISTER TO MEMORY.
;
ACT10:	JSR	R5,POINTM
	RTS	R5
;
;	IRTOAR - INSTRUCTION REGISTER TO ADDRESS REGISTER.
;
ACT11:	MOV	IIR,R0
	BIC	#177000,R0	;ONLY THE ADDRESS.
	MOV	R0,IAR
	JSR	R5,DISREG
	.WORD	IAR
	.POS	0,6,5,2
	RTS	R5
;
;	PCPLON - PROGRAM COUNTER PLUS ONE.
;
ACT12:	INC	IPC		;EXECUTE.
	JSR	R5,DISREG
	.WORD	IPC
	.POS	1,7,5,2
	RTS	R5
;
;	METOBR - MEMORY TO BUFFER REGISTER.
;
ACT13:	MOV	IAR,R0		;TAKE WORD ADDRESS.
	ASL	R0		;MAKE BYTE ADDRESS.
	ADD	#IMEM,R0
	MOV	(R0),IBR	;EXECUTE.
	JSR	R5,DISREG
	.WORD	IBR
	.POS	0,4,0,8.
	RTS	R5
;
;	MMREAD - READ MEMORY.
;
ACT14:	CMP	IAR,#MEMTOP	;HIGHER THAN MEMTOP?
	BHI	ACT14A		;ILLEGAL ADDRESS.
	RTS	R5
ACT14A:	MOV	#ERR2,R5	;ACORT TO ERROR ROUTINE.
	RTS	R5
;
;	MMWRIT - WRITE MEMORY.
;
ACT15:	MOV	IAR,R0		;TAKE ADDRESS.
	CMP	R0,#MEMTOP	;TOP ADDRESS?
	BHI	ACT15F		;ILLEGAL ADDRESS.
	ASL	R0		;MAKE BYTE ADDRESS.
	MOV	IBR,IMEM(R0)	;WRITE INTO MEMORY.
	ADD	#IMEM,R0
	MOV	R0,ACT15D	;TRANSFER REAL ADDRESS.
	MOV	IAR,R1
	SUB	IMEMVL,R1	;SUBSTRACT VIRTUAL BASE ADDRESS.
	CMPB	R1,#21.		;LOWEST POSITION?
	BHIS	ACT15E
	INC	R1
	CMP	R1,#9.
	BHI	ACT15A
	MOVB	#'0,ACT15D+4
	CLR	ACT15G
	BR	ACT15C
ACT15A:	CMP	R1,#19.
	BHI	ACT15B
	MOVB	#'1,ACT15D+4
	MOV	#10.,ACT15G
	BR	ACT15C
ACT15B:	CMP	R1,#29.
	BHI	ACT15C
	MOVB	#'2,ACT15D+4
	MOV	#20.,ACT15G
ACT15C:	SUB	ACT15G,R1
	ADD	#'0,R1		;REAL POSITION.
	MOVB	R1,ACT15D+5	;SHOW CURSOR POSITION.
	JSR	R5,DISMEM
ACT15D:	.WORD	0
	.POS	0,1,7,2
	JSR	R5,POINTM	;SHOW POINT.
ACT15E:	RTS	R5
ACT15F:	MOV	#ERR2,R5	;ABORT TO ERROR ROUTINE.
	RTS	R5
ACT15G:.WORD	0		;FOR OFFSET CALC.
;
;	ACCUCL - CLEAR ACCUMULATOR
;
ACT16:	CLR	IAC		;EXECUTE.
	JSR	R5,DISREG
	.WORD	IAC
	.POS	1,1,0,5
	RTS	R5
;
;	ACTNO  - NO ACTION, ALSO MEANS NO PAUSE FOR THE SCREEN.
;
ACTNO:	MOV	#MIC3,R5
	RTS	R5
;
;	SERVIC - SERVICE STATE
;
ACT17:	MOVB	ISQMOD,R2	;NO WAIT?
	BEQ	ACT17A
	CMPB	#1,R2		;AUTO STEP?
	BEQ	ACT17B
	CMPB	#2,R2		;USER STEP?
	BEQ	ACT17C
	IOT			;PROGRAM ERROR.
ACT17A:	TSTB	IOST		;KEYBOARD TOUCHED?
	BMI	ACT17D
	RTS	R5		;NO FURTHER ACTION.
ACT17B:	JSR	R5,WAIT		;WAIT NUMBER OF TICKS.
	.WORD	1,ISQMOD+2	;ACCORDING TO INSTRUCTION DELAY.
	BR	ACT17A
ACT17C:	JMP	TIMS2		;COMMON ROUTINE WITH MICROPAUSE.
ACT17D:	MOV	#ERR3,R5	;ABORT TO ERROR.
	RTS	R5
;
;	GOFETC - GO TO FETCH STATE
;
ACT18:	TST	MESENB		;NOTHING TO TAKE.
	BNE	ACT18A
	RTS	R5
ACT18A:	JSR	R5,OUT		;REMOVE INSTRUCTION.
	.WORD	MES43,0
	RTS	R5
;
;	GOEXEC - GO TO EXECUTE STATE
;
ACT19:	RTS	R5		;NO ACTION
;
;	EXEALU - EXECUTE THE FUNCTION IN THE ARITHMETIC UNIT
;
ACT20:	MOV	IINDEX,R0	;GET OLD INDEX
	JMP	@ALXTAB(R0)	;JUMP TO PROPER ROUTINE.
ACT209:				;ADD I
ACT201:	MOV	IALA,R0		;ADD
	ADD	IALB,R0
	BIC	#170000,R0	;12-BIT
	MOV	R0,IAL
	JSR	R5,CONSET	;SET CONDITION REGISTER.
	RTS	R5
ACT202:	MOV	IALB,IAL	;ISZ
	CLR	CONDZE		;PRESET CONDITION
	INC	IAL
	BIC	#170000,IAL	;12-BIT
	JSR	R5,CONSET	;SET CONDITION REGISTER.
	RTS	R5
ACT210:				;STR I
ACT211:				;SIZ
ACT212:				;SIM
ACT213:				;SIP
ACT203:
ACT204:	RTS	R5		;JMP
ACT205:	MOV	IALA,IAL	;IAC
	INC	IAL
	BIC	#170000,IAL	;12-BIT
	JSR	R5,CONSET	;SET CONDITION REGISTER.
	RTS	R5
ACT206:	MOV	IALA,R0		;CMA
	COM	R0
	BIC	#170000,R0	;12-BIT
	MOV	R0,IAL
	JSR	R5,CONSET	;SET CONDITION REGISTER.
	RTS	R5
ACT207:				;CLA
ACT208:	RTS	R5		;HLT
;
;	ALTOBR - ARITHMETIC UNIT OUTPUT TO BUFFER REGISTER.
;
ACT37:	MOV	IAL,IBR		;EXECUTE.
	JSR	R5,DISREG	;DISPLAY REGISTER
	.WORD	IBR
	.POS	0,4,0,8.
	RTS	R5
;
;	GOHALT - GO TO THE HALT CONDITION.
;
ACT39:	JSR	R5,OUT		;GO ON OR TO CONSOLE?
	.WORD	CMES15,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'G	;GO ON?
	BEQ	ACT39A
	CMPB	GENBUF,#'g
	BEQ	ACT39A
	CMPB	GENBUF,#'C	;TO CONSOLE?
	BEQ	ACT39B
	CMPB	GENBUF,#'c
	BEQ	ACT39B
	BR	ACT39
ACT39A:	JSR	R5,OUT		;SET FOR RUN.
	.WORD	GMSG02,12.
	JSR	R5,OUT		;CLEAR SUBTITLES.
	.WORD	MES01+2,6
	JSR	R5,OUT		;CLEAR ILLEGAL INSTRUCTION.
	.WORD	MES43,0
	RTS	R5
ACT39B:	MOV	#RST1A,R5
	RTS	R5		;ABORT TO CONSOLE.
;
;	BRTOAR	- BUFFER TO ADDRESS REGISTER
;
ACT40:	MOV	IBR,IAR		;EXECUTE.
	JSR	R5,DISREG	;DISPLAY IAR
	.WORD	IAR
	.POS	0,6,5,2
	RTS R5
;
;	MUSKIP - SKIP
;
ACT42:	RTS	R5		;NO ACTION.
;
;	E R R O R   R O U T I N E S
;
;	ERROR 1 - ILLEGAL INSTRUCTION.
;
ERR1:	JSR	R5,OUT
	.WORD	CMES16,0
ERR1A:	MOV	#MEX08A,MICPC	;GO TO HALT.
	JSR	R5,WAIT
	.WORD	0,100.
	JMP	MICENT		;BACK.
;
;	ERROR 2 - ILLEGAL MEMORY ADDRESS.
;
ERR2:	JSR	R5,OUT		;PRINT ERROR MESSAGE.
	.WORD	CMES17,0
	JMP	ERR1A
;
;	ERROR 3 - SOMEBODY HAS PUSHED SOMETHING DURING THE RUN
;
ERR3:	JSR	R5,OUT		;ASK IF MISTAKE
	.WORD	CMES11,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'Y	;YES.
	BEQ	ERR3A
	CMPB	GENBUF,#'y
	BEQ	ERR3A
	CMPB	GENBUF,#'N	;NO.
	BEQ	ERR3B
	CMPB	GENBUF,#'n
	BEQ	ERR3B
	BR	ERR3
ERR3A:	JSR	R5,OUT		;JUST GO ON.
	.WORD	GMSG02,12.
	JSR	R5,OUT		;SET RUN AND CLEAR SUBTITLE.
	.WORD	MES01+2,6
	JMP	MIC3		;GO ON.
ERR3B:	JMP	RST1A
;
;	SUBROUTINE TIMSEQ, CALL WITH JSR R5,TIMSEQ
;
;	TIME/PAUSE SEQUENCER, CALLED FROM THE MICROCODE-INTERPRETER.
;
TIMSEQ:	MOVB	SEQMOD,R2	;NOWAIT?
	BEQ	TIMS0
	CMPB	#1,R2		;AUTO STEP?
	BEQ	TIMS1
	CMPB	#2,R2		;USER STEP?
	BEQ	TIMS2
	IOT			;PROGRAM ERROR.!!!
TIMS0:	RTS	R5		;NOWAIT.
TIMS1:	JSR	R5,WAIT		;WAIT NUMBER OF TICKS.
	.WORD	1,SEQMOD+2	;ASKED BETWEEN MICRO STEPS.
	RTS	R5
TIMS2:	JSR	R5,OUT		;SET ON WAIT
	.WORD	GMSG01,12.
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#SPACE
	BNE	TIMS3		;SOMETHING ELSE IS THE MATTER
	JSR	R5,OUT
	.WORD	GMSG02,12.
	RTS	R5
TIMS3:	MOV	#ERR3,R5	;ABORT TO ERROR ROUTINE
	RTS	R5
;
;	SUBROUTINE IN, CALL WITH JSR R5,IN.
;	ROUTINE TO READ A NUMBER OF CHARACTERS FROM THE KEYBOARD AND
;	PUT THEM INTO GENBUF.
;	FIRST ARGUMENT IS THE NUMBER OF CHARACTERS.
;
IN:	MOV	R0,-(SP)	;SAVE
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	(R5)+,R2	;NUMBER OF CHAR.
	MOV	#GENBUF,R1
	QIOW$S	#IO.RVB,#5,#5,,#IOSTAT,,<R1,R2>
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0	;RESTORE
	RTS	R5
;
;	SUBROUTINE OUT, CALL WITH JSR R5,OUT.
;
;	ROUTINE TO SEND MESSAGES TO THE SCREEN.
;	FIRST ARGUMENT IS ADDRESS OF DATA BLOCK.
;	SECOND ARGUMENT IS THE LENGTH OF THE DATABLOCK IN BYTES.
;	IF LENGTH IS ZERO, THEN IT IS THE FIRST WORD OF THE DATA BLOCK.
;	IF AN ESC IS DETECTED, THE DELAY ROUTINE IS CALLED TO SLOW
;	DOWN THE DRAWING OF THE GRAPHIC LINES.
;
OUT:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	MOV	(R5)+,R0	;ADDRESS
	MOV	(R5)+,R1	;LENGTH
	BNE	OUT1
	MOV	(R0)+,R1	;LENGTH IS IN THE BLOCK.
OUT1:	MOV	#BOUT,R2	;AUXILIARY BUFFER
	MOV	R1,R3		;COUNT LENGTH.
OUT2:	CMPB	(R0),#ESC	;IS IT AN ESC?
	BEQ	OUT7
OUT3:	TST	GRQENB		;DELAY ENABLED?
	BEQ	OUT5
	TST	GRQMOD		;DELAY MODE ASKED FOR?
	BEQ	OUT5
	MOVB	(R0)+,R2	;GET BYTE
	MOV	R2,OUTAB	;PUT INTO MEMORY
	CMP	R2,#040		;PRINTABLE CHARACTER?
	BLOS	OUT4
	JSR	R5,WAIT
	.WORD	1,GRQMOD+2	;ADDRESS OF NUMBER OF DELAYED TICKS.
OUT4:	QIOW$S	#IO.WVB,#5,#5,,#IOSTAT,,<#OUTAB,#1>
	DEC	R3		;DECREMENT COUNTER
	BNE	OUT2
	BR	OUT6
OUT5:	MOVB	(R0)+,(R2)+	;MOVE BYTE FROM BUF TO BUF
	DEC	R3
	BNE	OUT2
	QIOW$S	#IO.WVB,#5,#5,,#IOSTAT,,<#BOUT,R1>
OUT6:	MOV	(SP)+,R4
	MOV	(SP)+,R3
	MOV	(SP)+,R2	;RESTORE
	MOV	(SP)+,R1	;RESTORE REGISTERS.
	MOV	(SP)+,R0
	RTS	R5
	BR	OUT3
OUT7:	CMPB	1(R0),'[	;NEXT IS [?
	BEQ	OUT8
	CMPB	2(R0),'J	;NEXT IS J?
	BEQ	OUT8
	CMPB	2(R0),'H	;OR H?
	BNE	OUT3
OUT8:	TST	GRQENB
	BEQ	OUT9
	TST	GRQMOD
	BEQ	OUT9
	QIOW$S	#IO.WVB,#5,#5,,#IOSTAT,,<#OUTAA,#1>
	BR	OUT3		;AND BACK
OUT9:	MOVB	#CR,(R2)+	;PUSH CR
	INC	R1		;INCREMENT LENGTH
	BR	OUT3		;ADD ESC AND GO TO NEXT.
;
;	SUBROUTINE COCBIN, CALL WITH JSR R5,OUT.
;
;	ROUTINE TO CONVERT OCTAL TO BINARY
;	FIRST WORD IS THE ADDRESS OF THE INPUT BUFFER, 2ND
;	WORD IS THE LENGTH, THE #RD WORD IS THE
;
COCBIN:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	(R5),R0		;TAKE ADDRESS
	MOV	2(R5),R1	;TAKE LENGTH
	INC	COCBA
COCB2:	CMPB	(R0),#60
	BLO	COCB1
	CMPB	(R0)+,#67
	BHI	COCB1
	DEC	R1		;LAST CHECKED?
	BNE	COCB2
	CLR	COCBA		;NO FAULTS.
	CLR	R2		;CLEAN RESULT.
	MOV	(R5),R0
	MOVB	(R0)+,R1	;FIRST OC
	BIC	#770,R1		;CONVERT FIRST BYTE.
	MOV	2(R5),R3	;GET NUMBER OF BYTES.
	DEC	R3		;I ALREADY HAVE ONE.
	BEQ	COCB1		;READY.
	MOVB	(R0)+,R2	;GET NEXT
	BIC	#770,R2
	JSR	R5,SHFLFT	;SHIFT LEFT
	.WORD	3		;3 TIMES
	BIS	R2,R1		;ADD
	DEC	R3		;DECREMENT BYTE COUNT.	
	BEQ	COCB1
	MOVB	(R0)+,R2	;GET 3RD CHAR.
	BIC	#770,R2
	JSR	R5,SHFLFT
	.WORD	3
	BIS	R2,R1
	DEC	R3
	BEQ	COCB1		;LAST?
	MOVB	(R0)+,R2	;GET 4TH CHAR,
	BIC	#770,R2
	JSR	R5,SHFLFT
	.WORD	3
	BIS	R2,R1		;ADD LAST.
COCB1:	MOV	R1,4(R5)	;PUT RESULT.
	ADD	#6,R5
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	R5		;RETURN.
;
;	SUBROUTINE WAIT, CALL WITH JRS R5,WAIT
;
;	ROUTINE TO WAIT A NUMBER OF TICKS.
;	FIRST ARGUMENT 0, THEN THE SECOND ARGUMENT IS A CONSTANT WHICH
;	THE NUMBER OF TICKS.
;	FIRST ARGUMENT 1, THEN THE SECOND ARGUMENT IS AN ADDRESS WHICH
;	CONTAINS THE NUMBER OF TICKS OF 20 MSEC TO WAIT.
;
WAIT:	MOV	R0,-(SP)	;SAVE
	MOV	(R5)+,R0	;GET FIRST ARGUMENT
	BNE	WAIT2
	MOV	(R5)+,R0	;GET CONSTANT
	MOV	R0,TIME+2
WAIT1:	MRKT$S	#1,TIME+2,#1
	WTSE$S	#1		;WAIT FOR FLAG
	MOV	(SP)+,R0	;RESTORE.
	RTS	R5
WAIT2:	MOV	@(R5)+,R0	;GET CONSTANT INDIRECTLY.
	MOV	R0,TIME+2
	BR	WAIT1
;
;	SUBROUTINE CBINOC, CALL WITH JSR R5,CBINOC
;
;	ROUTINE TO CONVERT FROM BINARY TO OCTAL.
;	FIRST ARGUMENT IS THE ADDRESS OF THE INTERNAL REGISTER.
;	SECOND TWO WORDS CONTAIN THE FOUR OCTAL BYTES.
;
CBINOC:	MOV	R0,-(SP)	;SAVE
	MOV	R1,-(SP)
	MOV	(R5)+,R0	;GET ADDRESS.
	ADD	#3,R5		;POINT TO LSB BYTE.
	MOV	(R0),R1		;GET BINARY NUMBER.
	BIC	#177770,R1	
	JSR	R4,SHIFT	;PUT 1ST OC IN PLACE.
	.WORD	0		;NUMBER OF SHIFTS.
	MOV	(R0),R1		;GET BINARY NUMBER.
	BIC	#177707,R1	
	JSR	R4,SHIFT	;REPEAT FOR 2ND OC.
	.WORD	3		;NUMBER OF SHIFTS.
	MOV	(R0),R1		;GET BINARY NUMBER.
	BIC	#177077,R1	
	JSR	R4,SHIFT	;REPEAT FOR 3RD OC.
	.WORD	6		;NUMBER OF SHIFTS.
	MOV	(R0),R1		;GET BINARY NUMBER.
	BIC	#170777,R1	
	JSR	R4,SHIFT	;REPEAT FOR 4TH OC.
	.WORD	9.		;NUMBER OF SHIFTS.
	ADD	#5,R5
	MOV	(SP)+,R1	;RESTORE
	MOV	(SP)+,R0
	RTS	R5
;
;	SUBROUTINE SHIFT, CALL WITH JSR R4,SHIFT. (NOT R5!!!!).
;
;	SHIFTS THE VALUE IN R1 A NUMBER OF TIMES TO THE RIGHT.
;	FIRST ARGUMENT IS THE NUMBER OF SHIFTS.
;	THEN OC IS MADE BY ADDING 030, AND STORED IN MEMORY,
;	POINTED TO BY R5. R5 IS DECREMENTED ONE.
;
SHIFT:	MOV	R0,-(SP)	;SAVE
	MOV	(R4)+,R0	;NUMBER OF TIMES.
SHIFT1:	TST	R0
	BEQ	SHIFT0		;READY?
	ASR	R1
	DEC	R0
	BR	SHIFT1
SHIFT0:	BIS	#60,R1		;MAKE OCTAL
	MOVB	R1,(R5)		;PUT IN MEMORY.
	DEC	R5		;DECREMENT POINTER.
	MOV	(SP)+,R0	;RESTORE.
	RTS	R4
;
;	SUBROUTINE SHFLFT, CALL WITH JSR R5,SHFLFT
;
;	ROUTINE TO SHIFT A VALUE IN R1 TO THE LEFT.
;	FIRST ARGUMENT IS THE NUMBER OF SHIFTS.
;
SHFLFT:	MOV	R0,-(SP)	;SAVE
	MOV	(R5)+,R0	;NUMBER OF TIMES.
SHL1:	TST	R0
	BEQ	SHL2
	ASL	R1
	DEC	R0
	BR	SHL1
SHL2:	MOV	(SP)+,R0	;RESTORE.
	RTS	R5
;
;	SUBROUTINE DISREG, CALL WITH JSR R5,DISREG
;
;	ROUTINE TO GIVE A BINARY OR OCTAL DISPLAY OF THE CONTENTS
;	OF A REGISTER ON THE SCREEN.
;	FIRST ARGUMENT IS THE ADDRESS OF THE INTERNAL REGISTER.
;	AFTER THAT EIGHT BYTES MUST FOLLOW.
;
DISREG:	MOV	R0,-(SP)	;SAVE
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	TST	OCBINR		;OCTAL OR BINARY?
	BNE	DISR2		;BINARY
	MOV	(R5)+,DISR1	;MOVE ADDRESS
	JSR	R5,CBINOC	;CONVERT BINARY TO OCTAL
DISR1:	.WORD	0		;ADDRESS OF REGISTER
	.BLKB	4		;RESULT
	MOV	#SPACE,R1
	MOV	#GENBUF,R0
	MOV	#DISR1+2,R2	;OCTAL RESULT.
	MOV	(R5)+,(R0)+	;TRANSFER POSITION DATA
	MOV	(R5)+,(R0)+
	MOV	(R5)+,(R0)+
	MOV	(R5)+,(R0)+
	MOVB	R1,(R0)+	;SPACE
	MOVB	(R2)+,(R0)+	;OCTAL
	MOVB	R1,(R0)+	;SPACE
	MOVB	R1,(R0)+	;SPACE
	MOVB	(R2)+,(R0)+	;OCTAL
	MOVB	R1,(R0)+	;SPACE
	MOVB	R1,(R0)+	;SPACE
	MOVB	(R2)+,(R0)+	;OCTAL
	MOVB	R1,(R0)+	;SPACE
	MOVB	R1,(R0)+	;SPACE
	MOVB	(R2)+,(R0)+	;OCTAL
	MOVB	R1,(R0)+	;SPACE
	BR	DISR4
DISR2:	MOV	@(R5),R1	;MOVE DATA
	MOV	#GENBUF,R0
	ADD	#2,R5		;SKIP DATA FIELD
	MOV	(R5)+,(R0)+	;TRANSFER POSITION DATA
	MOV	(R5)+,(R0)+
	MOV	(R5)+,(R0)+
	MOV	(R5)+,(R0)+
	ADD	#12.,R0		;POINT TO END 
	MOV	#12.,R3
DISR3:	MOV	R1,R2
	BIC	#177776,R2	;KEEP BIT 0
	BIS	#60,R2		;MAKE OCTAL ASCII
	MOVB	R2,-(R0)	;STORE BACKWARDS
	ASR	R1		;SHIFT
	DEC	R3		;DECREMENT COUNTER.
	BNE	DISR3		;BACK.
DISR4:	JSR	R5,OUT		;PRINT
	.WORD	GENBUF,20.
	MOV	(SP)+,R3	;RESTORE
	MOV	(SP)+,R2	;RESTORE
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	R5
;
;	SUBROUTINE DISMEM, CALL WITH JSR R5,DISMEM
;
;	MAKES AN OCTAL DISPLAY OF A MEMORY LOCATION.
;	FIRST ARGUMENT IS THE REAL ADDRESS OF THE MEMORY LOCATION.
;	AFTER THAT 8 BYTES FOLLOW FOR CURSOR POSITIONING.
;	IN IAR IS THE ADDRESS OF WHAT IS DISPLAYED.
;
DISMEM:	MOV	R0,-(SP)	;SAVE
	MOV	R1,-(SP)
	MOV	(R5)+,DISM2	;TRANSFER MEMORY CONTENTS.
	JSR	R5,CBINOC	;MEMORY ADDRESS
DISM1:	.WORD	IAR
	.BLKB	4		;OCTAL BYTES
	MOV	#GENBUF,R0
	MOV	(R5)+,(R0)+	;TRANSFER 'ESC['
	MOV	(R5)+,(R0)+	;TRANSFER 'YY'
	MOV	(R5)+,(R0)+	;TRANSFER ';X'
	MOV	(R5)+,(R0)+	;TRANSFER 'XH'
	MOV	DISM1+2,(R0)+	;ADD OCTAL.
	MOV	DISM1+4,(R0)+
	MOVB	#SPACE,(R0)+
	JSR	R5,CBINOC	;MEMORY CONTENTS.
DISM2:	.WORD	0
	.BLKB	4		;RESULT : 4 OC BYTES.
	MOV	#DISM2+2,R1
	MOVB	(R1)+,(R0)+
	MOVB	(R1)+,(R0)+
	MOVB	(R1)+,(R0)+
	MOVB	(R1)+,(R0)+
	JSR	R5,OUT
	.WORD	GENBUF,17.
	MOV	(SP)+,R1	;RESTORE
	MOV	(SP)+,R0
	RTS	R5
;
;	SUBROUTINE DISCON, CALL WITH JSR R5,DISCON
;
;	SUBROUTINE TO DISPLAY THE CONTENTS OF THE CONDITION REGISTER.
;	CONDZE IS THE CONDITION REGISTER.
;	00 : POSITIVE, 01 : ZERO, 10 : MINUS.
;
DISCON:	BIT	#1,CONDZE	;ZERO?
	BNE	DISCO1		;YES
	BIT	#2,CONDZE	;MINUS
	BNE	DISCO2		;YES, MINUS
	JSR	R5,OUT
	.WORD	CMES25,0	;POSITIVE
	RTS	R5
DISCO1:	JSR	R5,OUT
	.WORD	CMES24,0	;ZERO
	RTS	R5
DISCO2:	JSR	R5,OUT
	.WORD	CMES26,0	;MINUS
	RTS	R5
;
;	SUBROUTINE CONSET, CALL WITH JSR R5,CONSET
;
;	THIS SUBROUTINE SETS THE CONDITION REGISTER REGARDLESS THE
;	OUTPUT OF THE ARITHMETIC UNIT ial.
;
;	BIT 0 IS THE ZERO BIT, BIT 1 IS THE MINUS BOT.
;	BIT 0 AND 1 BECOME 00 IF THE RESULT APPEARS TO BE POSITIVE.
;
CONSET:	MOV	R0,-(SP)	;SAVE
	MOV	IAL,R0		;PLACE OUTPUT ALU IN R0 AND TEST.
	BEQ	CONSE2		;ZERO RESULT.
	BIT	#4000,R0	;SIGN BIT SET?
	BNE	CONSE3		;YES, SO MINUS BIT 1
	CLR	CONDZE		;POSITIVE RESULT
CONSE1:	MOV	(SP)+,R0	;RESTORE
	JSR	R5,DISCON	;DISPLAY ON SCREEN
	RTS	R5
CONSE2:	MOV	#1,CONDZE	;SET ZERO BIT.
	BR	CONSE1
CONSE3:	MOV	#2,CONDZE	;SET MINUS BIT
	BR	CONSE1
;
;	SUBROUTINE POINTM, CALL WITH JSR R5,POINTM
;
;	SHOW AN ARROW AT THE PLACE WHERE THE MEMORY IS BEING ACCESSED.
;	ADDRESS IS GIVER BY IAR.
;
POINTM:	MOV	R0,-(SP)	;SAVE
	MOVB	#SPACE,POINT6+8.;REMOVE PREVIOUS ARROW
	JSR	R5,OUT
	.WORD	POINT6,9.
	MOV	IAR,R0
	SUB	IMEMVL,R0	;BASE VISIBLE ADDRESS OFF.
	CMP	R0,#21.		;NOT VISIBLE?
	BHIS	POINT4
	INC	R0		;ADJUST FOR POSISTION
	CMP	R0,#9.		;LESS THAN 10.?
        BHI     POINT1		
        MOVB    #'0,POINT6+2	;YES
        CLR     POINT5
        BR      POINT3
POINT1: CMP     R1,#19.		;LESS THAN 20.?
        BHI     POINT2
        MOVB    #'1,POINT6+2	;YES
        MOV     #10.,POINT5
        BR      POINT3
POINT2: MOVB    #'2,POINT6+2
        MOV     #20.,POINT5
POINT3: SUB     POINT5,R0
	ADD	#'0,R0		;ADD POSITION.
	MOVB	R0,POINT6+3	;SET ROW POSITION
	MOVB	#'>,POINT6+8.	;ARROW IN BUFFER
	JSR	R5,OUT		;PRINT >
	.WORD	POINT6,9.	;LENGTH.
POINT4:	MOV	(SP)+,R0	;RESTORE
	RTS	R5
POINT5:	.WORD	0
POINT6:	.POS	0,1,7,1
	.BYTE	'>
	.EVEN
;
;	SUBROUTINE SHOMEM, CALL WITH JSR R5,SHOMEM
;
;	SHOW THE CONTENTS OF THE ENTIRE MEMORY IN CONSOLE MODE.
;	FIRST ARGUMENT :
;	1 = CLEAN SCREEN, 0 = DO NOT BOTHER, -1 = DISPLAY A WORD.
;	-2 = REMOVE OLD POINTS INDICATED BY OLDVL AND OLDVH AND SHOW
;	NEW POINTS.
;
SHOMEM:	MOV	R0,-(SP)	;SAVE
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	IAR,-(SP)	;SAVE IAR
	MOV	CMES18,SHOM1+2	;LENGTH NORMAL+CLEAN
	MOV	#CMES18+2,SHOM1	;ADDRESS+CLEAN
	MOV	(R5)+,R0	;IS THAT WANTED?
	BNE	SHOM1B
	JMP	SHOM2
SHOM1B:	BMI	SHOM3		;ONLY ONE, SO NO TITLES.
SHOM1A:	JSR	R5,OUT
SHOM1:	.WORD	0,0
SHOM3:	MOV	#3,R0		;ROWS, Y
	MOV	#2,R1		;COLUMS, X
	CLR	IAR		;ADDRESS ON 0
SHOM4:	MOV	IAR,R2
	ASL	R2		;BYTE ADDRESS
	ADD	#IMEM,R2
	MOV	R2,SHOM5	;REAL MEMORY ADDRESS OVER.
	MOV	R1,SHOM1	;COLUMN POSITION
	CMP	SHOM1,#9.	;ONE OF 2,13,24,35,46,57,68
	BHI	SHOM4B
	MOVB	#'0,SHOMC+5
	CLR	TMPX
SHOM4B:	CMP	SHOM1,#13.	;IN 10 RANGE?
	BNE	SHOM4C
	MOVB	#'1,SHOMC+5	;MAKE X IN THE 10 RANGE
	MOV	#10.,TMPX	;MAKE IT SINGLE DIGIT
	BR	SHOM4H
SHOM4C: CMP	SHOM1,#24.	;IN 20 RANGE?
	BNE	SHOM4D
	MOVB	#'2,SHOMC+5	;MAKE X IN THE 20 RANGE
	MOV	#20.,TMPX
	BR	SHOM4H
SHOM4D: CMP	SHOM1,#35.	;IN 30 RANGE?
	BNE	SHOM4E
	MOVB	#'3,SHOMC+5	;MAKE X IN THE 30 RANGE
	MOV	#30.,TMPX
	BR	SHOM4H
SHOM4E: CMP	SHOM1,#46.	;IN 40 RANGE?
	BNE	SHOM4F
	MOVB	#'4,SHOMC+5	;MAKE X IN THE 40 RANGE
	MOV	#40.,TMPX
	BR	SHOM4H
SHOM4F: CMP	SHOM1,#57.	;IN 50 RANGE?
	BNE	SHOM4G
	MOVB	#'5,SHOMC+5	;MAKE X IN THE 50 RANGE
	MOV	#50.,TMPX
	BR	SHOM4H
SHOM4G: CMP	SHOM1,#68.	;IN 60 RANGE?
	BNE	SHOM4H
	MOVB	#'6,SHOMC+5	;MAKE X IN THE 60 RANGE
	MOV	#60.,TMPX
SHOM4H:	SUB	TMPX,SHOM1	;ADJUST TO SINGLE DIGIT
	ADD	#'0,SHOM1	;MAKE IT A NUMERICAL CHARACTER
	MOVB	SHOM1,SHOMC+6	;TRANSFER X
	MOV	R0,SHOM1	;ROW POSITION 3 - 17
	CMP	SHOM1,#9.
	BHI	SHOM4I
	MOVB	#'0,SHOMC+2
	CLR	TMPY
SHOM4I:	CMP	SHOM1,#10.	;IN 10 RANGE?
	BNE	SHOM4J
	MOVB	#'1,SHOMC+2	;MAKE Y IN THE 10 RANGE
	MOV	#10.,TMPY	;MAKE SINGE DIGIT VALUE
SHOM4J:	SUB	TMPY,SHOM1	;ADJUST TO SINGLE DIGIT
	ADD	#'0,SHOM1	;MAKE IT A CHARACTER
	MOVB	SHOM1,SHOMC+3	;TRANSFER Y.
	CMP	-2(R5),#-1.	;ONE WORD?
	BNE	SHOM4A		;NO
	CMP	(SP),IAR	;IAR EQUAL?
	BNE	SHOM5A
SHOM4A:	CMP	-2(R5),#-2.	;NOT ONLY AT POINTS DISPLAY
	BEQ	SHOM5A
	JSR	R5,DISMEM	;DISPLAY MEMORY
SHOM5:	.WORD	0
SHOMC:	.POS	0,1,0,1
SHOM5A:	CMP	IAR,IMEMVL	;BELOW LOWER BOUNDARY.
	BLO	SHOM6A		;NO STAR
	CMP	IAR,IMEMVH	;ABOVE HIGH BOUNDARY?
	BHI	SHOM6A
	MOVB	SHOMC+2,SHOMA+2	;TRANFER Y.
	MOVB	SHOMC+3,SHOMA+3	
	MOVB	SHOMC+5,SHOMA+5	;TRANFER X.
	MOVB	SHOMC+6,SHOMA+6
	CMP	-2(R5),#-1.	;ONE WORD?
	BNE	SHOM5B
	CMP	(SP),IAR	;MATCH OLD AND RUNNING IAR?
	BNE	SHOM6
SHOM5B:	JSR	R5,OUT		;MAKE FIRST '0' A '*'
	.WORD	SHOMA,9.	;SHOW VISIBLE MEMORY.
SHOM6:	INC	IAR
	CMP	#MEMTOP+1,IAR	;LAST?
	BEQ	SHOM7
	INC	R0		;INCREMENT Y
	CMP	R0,#19.		;LOWEST Y POS?
	BEQ	SHOM8
	JMP	SHOM4		;BACK AND REPEAT.
SHOM8:	MOV	#3,R0		;BACK TO ROW 3
	ADD	#11.,R1		;ADVANCE 11 POS. TO COLS
	JMP	SHOM4
SHOM6A:	CMP	IAR,OLDVL	;COMPARE OLD BOUNDARIES.
	BLO	SHOM6
	CMP	IAR,OLDVH
	BHI	SHOM6
	CMP	-2(R5),#-2.	;ONLY POINTS?
	BNE	SHOM6		;NO
	MOVB	SHOMC+2,SHOMB+2	;TRANSFER X.
	MOVB	SHOMC+3,SHOMB+3
	MOVB	SHOMC+5,SHOMB+5	;TRANSFER Y.
	MOVB	SHOMC+6,SHOMB+6
	JSR	R5,OUT		;CHANGE STAR IN 0
	.WORD	SHOMB,9.
	BR	SHOM6
SHOM2:	SUB	#4,SHOM1+2	;DECREMENT LENGTH NO CLEAR.
	ADD	#4,SHOM1	;INCREMENT ADDRESS.
	JMP	SHOM1A
SHOM7:	MOV	(SP)+,IAR	;RESTORE
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	R5
	.EVEN
SHOMA:	.POS	0,0,0,0		;PLACEHOLDER
	.BYTE	'*
	.EVEN
SHOMB:	.POS	0,0,0,0		;PLACEHOLDER
	.BYTE	'0
	.EVEN
;
; --------------------------------------------------------------------
;
	.NLIST	BEX
	.ENABL	LC
;
;	MICRO-STEP MESSAGES
;
MES01:	.WORD	MES02-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<BRTOME> : buffer register to memory/
	.EVEN
;
MES02:	.WORD	MES03-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<BRTOAL> : buffer register to arithmetic unit/
	.EVEN
;
MES03:	.WORD	MES04-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<ACTOAL> : accumulator to arithmetic unit/
	.EVEN
;
MES04:	.WORD	MES05-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<ALTOAC> : arithmetic unit to accumulator/
	.EVEN
;
MES05:	.WORD	MES06-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<ACTOBR> : accumulator to buffer register/
	.EVEN
;
MES06:	.WORD	MES07-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<BRTOIR> : buffer register to instruction register/
	.EVEN
;
MES07:	.WORD	MES08-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<IRTODC> : instruction to decoder and control unit/
	.EVEN
;
MES08:	.WORD	MES09-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<IRTOPC> : address of instruction to the program counter/
	.EVEN
;
MES09:	.WORD	MES10-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<PCTOAR> : program counter to address register/
	.EVEN
;
MES10:	.WORD	MES11-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<ARTOME> : address register to memory/
	.EVEN
;
MES11:	.WORD	MES12-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<IRTOAR> : address of instruction register to address register/
	.EVEN
;
MES12:	.WORD	MES13-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<PCPLON> : increment program counter with one/
	.EVEN
;
MES13:	.WORD	MES14-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<METOBR> : memory output to buffer register/
	.EVEN
;
MES14:	.WORD	MES15-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<MMREAD> : read from memory/
	.EVEN
;
MES15:	.WORD	MES16-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<MMWRIT> : write to memory/
	.EVEN
;
MES16:	.WORD	MES17-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<ACCUCL> : clear accumulator and make it zero/
	.EVEN
;
MES17:	.WORD	MES18-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<SERVIC> : go to the service state/
	.EVEN
;
MES18:	.WORD	MES19-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<GOFETC> : go to the fetch state, get next instruction/
	.EVEN
;
MES19:	.WORD	MES20-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<GOEXEC> : go to the execute state, execute instruction/
	.EVEN
;
MES20:	.WORD	MESCL-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<EXEALU> : execute instruction function in arithmetic unit/
	.EVEN
;
MESCL:	.WORD	MES37-.-2
	.POS	2,4,1,4
	.CLIN
	.EVEN
;
MES37:	.WORD	MES39-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<ALTOBR> : result arithmetic unit goes to buffer register/
	.EVEN
;
MES39:	.WORD	MES40-.-2
	.POS	2,4,1,4
	.CLIN
	.BYTE	BELL
	.ASCII	/<GOHALT> : stop!/
	.EVEN
;
MES40:	.WORD	MES42-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<BRTOAR> : address in the buffer register to address register/
	.EVEN
;
MES42:	.WORD	MES43-.-2
	.POS	2,4,1,4
	.CLIN
	.ASCII	/<MUSKIP> : compare instruction condition with alu output /
	.EVEN
;
MES43:	.WORD	MES00-.-2
	.POS	2,3,1,4
	.STRING	54.,SPACE
	.POS	1,7,4,1
	.STRING	5.,SPACE
	.EVEN
;
MES00:
;
;	G R A P H I C   D A T A   A R E A
;
;	PROCESSOR LAYOUT
;
LAYOUT:	.WORD	LAYEND-.-2
	.BYTE	ESC,'[,'H,ESC,'[,'J	;ERASE SCREEN

	.POS	0,2,0,6			;DRAW BUFFER REGISTER BOX
;	.ASCII	/BUFFER REG./
	.ASCII	/BR/
	.POS	0,3,0,6	
	.REG	'*,'*,'*

	.POS	0,4,5,0			;DRAW ADDRESS REGISTER BOX
;	.ASCII	/ADDR.REG./
	.ASCII	/AR/
	.POS	0,5,5,0	
	.REG	'*,'*,'*

	.POS	0,9.,0,3		;DRAW ACCUMULATOR BOX
	.ASCII	/ACCU/
	.POS	1,0,0,3
	.REG	'*,'*,'*

	.POS	0,9.,3,1		;DRAW INSTRUCTION REGISTER BOX
;	.ASCII	/INSTR.REG./
	.ASCII	/IR/
	.POS	1,0,3,1	
	.REG	'*,'*,'*

	.POS	1,5,5,0			;DRAW PROGRAM COUNTER BOX
;	.ASCII	/PROG.COUNT./
	.ASCII	/PC/
	.POS	1,6,5,0	
	.REG	'*,'*,'*

	.POS	1,6,3,1			;DRAW DECODER BOX
	.REG	'-,'[,']
	.POS	1,7,3,2	
	.ASCII	/DECODER:/

	.POS	1,9.,3,8.		;DRAW CONTROL BOX
	.BYTE	'|
	.POS	2,0,3,1
	.REG	'=,'#,'#
	.POS	2,1,3,2
	.ASCII	/CONTROL:/

	.POS	2,3,0,1			;COMMENT
	.ASCII	/Instruction: /
	.POS	2,4,0,1	
	.ASCII	/Micro-step :/

	.POS	0,1,7,0			;DRAW MEMORY AREA
	.DOWN	22.,'.
	.POS	2,2,7,2	
	.ASCII	/MEMORY/
	.POS	2,3,7,3
	.ASCII	/BANK/

	.POS	1,5,1,2			;DRAW ALU BOX
	.ASCII	/ALU/
	.POS	1,6,1,2	
	.STRING	14.,'*
	.POS	2,0,1,2
	.STRING	14.,'*
	.POS	1,8.,1,4
	.ASCII	/ARITHMETIC/
	.POS	1,9.,1,7
	.ASCII	/UNIT/
	.POS	1,7,1,2
	.DOWN	3,'*
	.POS	1,7,2,5
	.DOWN	3,'*
	.BYTE	0			;END INITIAL SET-UP
LAYEND:
	.EVEN
;
;	FLOW GRAPHICS
;
;	BRTOME - DRAW LINE FROM BR TO MEMORY
;
GRPH01:	.WORD	GRPH21-.-2
	.POS	0,2,1,9.
	.BYTE	'|
	.POS	0,1,1,9.
	.ASCII	/+---->---->/
	.POS	0,1,3,0
	.ASCII	/---->---->/
	.POS	0,1,4,0
	.ASCII	/---->---->/
	.POS	0,1,5,0
	.ASCII	/---->---->/
	.POS	0,1,6,0
	.ASCII	/---->---->/
	.EVEN
;
;	BRCLME - ERASE LINE FROM BR TO MEMORY
;
GRPH21:	.WORD	GRPH02-.-2
	.POS	0,2,1,9.
	.BYTE	SPACE
	.POS	0,1,1,9.
	.STRING	51.,SPACE
	.POS	0,2,3,3
	.STRING	16.,SPACE
	.EVEN
;
;	BRTOAL - DRAW LINE FROM BR TO ALU
;
GRPH02:	.WORD	GRPH22-.-2
	.POS	0,6,1,3
	.BYTE	'|,LF,BS,'|,LF,BS,'+
	.ASCII	/---------+/
	.POS	0,9.,2,3
	.DOWN	6,'|
	.POS	1,5,2,3
	.BYTE	'V
	.EVEN
;
;	BRCLAL - ERASE LINE FROM BR TO ALU
;
GRPH22:	.WORD	GRPH03-.-2
	.POS	0,6,1,3
	.BYTE	SPACE,LF,BS,SPACE,LF,BS
	.STRING	11.,SPACE
	.POS	0,9.,2,3
	.DOWN	7,SPACE
	.EVEN
;
;	ACTOAL - DRAW LINE FROM ACCU TO ALU
;
GRPH03:	.WORD	GRPH23-.-2
	.POS	1,3,1,0
	.BYTE	'|,LF,BS,'+
	.STRING	8.,'-
	.BYTE	'+
	.POS	1,5,1,9.
	.BYTE	'V
	.EVEN
;
;	ACCLAL - ERASE LINE FROM ACCU TO ALU
;
GRPH23:	.WORD	GRPH04-.-2
	.POS	1,3,1,0
	.BYTE	SPACE,LF,BS
	.STRING	10.,SPACE
	.POS	1,5,1,9.
	.BYTE	SPACE
	.EVEN
;
;	ALTOAC - DRAW LINE FROM ALU TO ACCU
;
GRPH04:	.WORD	GRPH24-.-2
	.POS	2,1,1,8.
	.BYTE	'|,LF,BS,'+
	.POS	2,2,1,7
	.LEF	16.,'-
	.POS	2,2,0,1
	.BYTE	'+
	.POS	2,1,0,1
	.UP	13.,'|
	.POS	0,8.,0,1
	.BYTE	'+
	.STRING	8.,'-
	.BYTE	'+,BS,LF,'V
	.EVEN
;
;	ALCLAC - ERASE LINE FROM ALU TO ACCU
;
GRPH24:	.WORD	GRPH05-.-2
	.POS	2,1,1,8.
	.BYTE	SPACE,LF,BS
	.LEF	18.,SPACE
	.UP	14.,SPACE
	.STRING	10.,SPACE
	.BYTE	BS,LF,SPACE
	.EVEN
;
;	ACTOBR - DRAW LINE FROM ACCU TO BR
;
GRPH05:	.WORD	GRPH25-.-2
	.POS	0,9.,1,2
	.UP	3,'|
	.POS	0,6,1,2
	.BYTE	'^
	.EVEN
;
;	ACCLBR - ERASE LINE FROM ACCU TO BR
;
GRPH25:	.WORD	GRPH06-.-2
	.POS	0,9.,1,2
	.UP	4,SPACE
	.EVEN
;
;	BRTOIR - DRAW LINE FROM BR TO IR
;
GRPH06:	.WORD	GRPH26-.-2
	.POS	0,6,1,3
	.BYTE	'|,LF,BS,'+
	.STRING	27.,'-
	.BYTE	'+
	.POS	0,8.,4,1
	.BYTE	'|
	.POS	0,9.,4,1
	.BYTE	'V
	.EVEN
;
;	BRCLIR - ERASE LINE FROM BR TO IR
;
GRPH26:	.WORD	GRPH07-.-2
	.POS	0,6,1,3
	.BYTE	SPACE,LF,BS
	.STRING	28.,SPACE
	.DOWN	3,SPACE
	.EVEN
;
;	IRTODC - DRAW LINE FROM IR TO DECODER
;
GRPH07:	.WORD	GRPH27-.-2
	.POS	1,3,3,8.
	.DOWN	2,'|
;	.POS	1,5,3,8.
	.BYTE	'V
	.EVEN
;
;	IRCLDC - ERASE LINE FROM IR TO DECODER
;
GRPH27:	.WORD	GRPH08-.-2
	.POS	1,3,3,8.
	.DOWN	3,SPACE
	.EVEN
;
;	IRTOPC - DRAW LINE FROM IR TO PC
;
GRPH08:	.WORD	GRPH28-.-2
	.POS	1,3,4,0
	.BYTE	'|,LF,BS,'+
	.STRING	21.,'-
	.BYTE	'+,LF,BS,'V
	.EVEN
;
;	IRCLPC - CLEAR LINE FROM IR TO PC
;
GRPH28:	.WORD	GRPH09-.-2
	.POS	1,3,4,0
	.BYTE	SPACE,LF,BS
	.STRING	23.,SPACE
	.BYTE	LF,BS,SPACE
	.EVEN
;
;	PCTOAR - DRAW LINE FROM PC TO AR
;
GRPH09:	.WORD	GRPH29-.-2
	.POS	1,5,5,8.
	.UP	7,'|
;	.POS	0,8.,5,8
	.BYTE	'^
	.EVEN
;
;	PCCLAR - ERASE LINE FROM PC TO AR
;
GRPH29:	.WORD	GRPH10-.-2
	.POS	1,5,5,8.
	.UP	8.,SPACE
	.EVEN
;
;	ARTOME - DRAW LINE FORM AR TO MEMORY
;
GRPH10:	.WORD	GRPH30-.-2
	.POS	0,6,6,6
	.ASCII	/--->/
	.EVEN
;
;	ARCLME - ERASE LINE FORM AR TO MEMORY
;
GRPH30:	.WORD	GRPH11-.-2
;	.POS	0,4,6,1
;	.STRING	9.,SPACE
	.POS	0,6,6,6
	.STRING	4,SPACE
	.EVEN
;
;	IRTOAR
;	DRAW LINE FROM IR TO AR
;
GRPH11:	.WORD	GRPH31-.-2
	.POS	1,3,4,0
	.BYTE	'|,LF,BS,'+
	.STRING	17.,'-
	.BYTE	'+
	.POS	1,3,5,8.
	.UP	5,'|
	.POS	0,8.,5,8.
	.BYTE	'^
	.EVEN
;
;	IRCLAR - ERASE LINE FROM IR TO AR
;
GRPH31:	.WORD	GRPH12-.-2
	.POS	1,3,4,0
	.BYTE	SPACE,LF,BS
	.STRING	19.,SPACE
	.BYTE	BS
	.UP	7,SPACE
	.EVEN
;
;	PCPLON - DRAW LINE AND BOX TO PC SUB-BOX
;
GRPH12:	.WORD	GRPH32-.-2
	.POS	1,7,6,7
	.BYTE	'<,'+,LF,BS
	.DOWN	3,'|
	.POS	2,1,6,4
	.ASCII	/----+/
	.POS	2,0,6,0
	.STRING	4,'#
	.POS	2,1,6,0
	.ASCII	/#  #/
	.POS	2,2,6,0
	.STRING	4,'#
	.POS	2,1,5,7
	.ASCII	/+--/
	.POS	2,0,5,7
	.UP	2,'|
	.POS	2,1,6,1
	.ASCII	/+1/
	.EVEN
;
;	PCCLON - ERASE LINE AND BOX TO PC SUB-BOX
;
GRPH32:	.WORD	GRPH13-.-2
	.POS	1,7,6,7
	.BYTE	SPACE
	.DOWN	5,SPACE
	.POS	1,9.,5,7
	.STRING	13.,SPACE
	.POS	2,0,5,7
	.STRING	13.,SPACE
	.POS	2,1,5,7
	.STRING	13.,SPACE
	.POS	2,2,6,0
	.STRING	4,SPACE
	.EVEN
;
;	METOBR - DRAW LINE FROM MEMORY TO BR
;
GRPH13:	.WORD	GRPH33-.-2
	.POS	0,1,6,0
	.ASCII	/--<----<--/
	.POS	0,1,5,0
	.ASCII	/--<----<--/
	.POS	0,1,4,0
	.ASCII	/--<----<--/
	.POS	0,1,3,0
	.ASCII	/--<----<--/
	.POS	0,1,1,9.
	.ASCII	/+--<----<--/
	.POS	0,2,1,9.
	.BYTE	'V
	.EVEN
;
;	MECLBR - ERASE LINE FROM MEMORY TO BR
;
GRPH33:	GRPH14-.-2
	.POS	0,1,6,9.
	.LEF	10.,SPACE
	.POS	0,1,5,9.
	.LEF	10.,SPACE
	.POS	0,1,4,9.
	.LEF	10.,SPACE
	.POS	0,1,3,9.
	.LEF	10.,SPACE
	.POS	0,1,2,9.
	.LEF	10.,SPACE
	.POS	0,1,1,9.
	.LEF	10.,SPACE
	.POS	0,2,1,9.
	.BYTE	SPACE
	.EVEN
;
;	MMREAD - DRAW 'MEMORY READ' TEXT
;
GRPH14:	.WORD	GRPH34-.-2
	.POS	0,2,3,0
	.ASCII	/$$ READ MEMORY $$/
	.EVEN
;
;	MMCLAD - ERASE 'MEMORY READ / WRITE' TEXT
;
GRPH34:
GRPH35:	.WORD	GRPH15-.-2
	.POS	0,2,3,0
	.STRING	18.,SPACE
	.EVEN
;
;	MMWRIT - DRAW 'MEMORY WRITE' TEXT
;
GRPH15:	.WORD	GRPH16-.-2
	.POS	0,2,3,0
	.ASCII	/$$ WRITE MEMORY $$/
	.EVEN
;
;	ACCUCL - DRAW CLEAR ACCU GRAPH.
;
GRPH16:	.WORD	GRPH36-.-2
	.POS	0,7,0,7
	.STRING	8.,'0
	.POS	0,8.,1,0
	.BYTE	'|,LF,BS,'V
	.EVEN
;
;	ACCLCL - ERASE CLEAR ACCU GRAPH
;
GRPH36:	.WORD	GRPH17-.-2
	.POS	0,7,0,7
	.STRING	8.,SPACE
	.POS	0,8.,1,0
	.BYTE	SPACE,LF,BS,SPACE
	.EVEN
;
;	SERVIC - PLACE TEXT IN DECODER
;
GRPH17:	.WORD	GRPH18-.-2
	.POS	2,1,4,0
	.ASCII	/SERVIC/
	.EVEN
;
;	GOFETC - PLACE TEXT IN DECODER
;
GRPH18:	.WORD	GRPH19-.-2
	.POS	2,1,4,0
	.ASCII	/FETCH /
	.EVEN
;
;	GOEXEC - PLACE TEXT IN DECODER
;
GRPH19:	.WORD	GRPH20-.-2
	.POS	2,1,4,0
	.ASCII	/EXEC  /
	.EVEN
;
;	EXEALU - DRAW '+' SIGNS INTO ALU
;
GRPH20:	.WORD	GRPH37-.-2
	.POS	1,7,1,5
	.ASCII	/+ + + + /
	.POS	1,7,1,5
	.ASCII	/ + + + +/
	.POS	1,7,1,5
	.ASCII	/+ + + + /
	.POS	1,7,1,5
	.ASCII	/ + + + +/
	.POS	1,7,1,5
	.ASCII	/+ + + + /
	.POS	1,7,1,5
	.ASCII	/ + + + +/
	.POS	1,7,1,5
	.STRING 8.,SPACE
	.EVEN
;
;	ALTOBR - DRAW LINE FROM ALU TO BR
;
GRPH37:	.WORD	GRPH38-.-2
	.POS	2,1,1,9.
	.BYTE	'|,LF,BS,'+
	.STRING	8.,'-
	.BYTE	'+
	.POS	2,1,2,8.
	.UP	14.,'|
	.BYTE	'+,BS,BS
	.LEF	12.,'-
	.UP	1,'+
	.BYTE	'^
	.EVEN
;
;	ALCLBR - ERASE LINE FROM ALU TO BR
;
GRPH38:	.WORD	GRPH39-.-2
	.POS	2,1,1,9.
	.BYTE	SPACE,LF,BS
	.STRING	10.,SPACE
	.POS	2,2,2,8.
	.UP	15.,SPACE
	.LEF	13.,SPACE
	.UP	2,SPACE
	.EVEN
;
;	GOHALT - PLACE TEXT
;
GRPH39:	.WORD	GRPH40-.-2
	.POS	2,2,5,0
	.ASCII	/HALT/
	.EVEN
;
;	BRTOAR - DRAW LINE FROM BUFFER REGISTER TO ADDRESS REGISTER
;
GRPH40:	.WORD	GRPH41-.-2
	.POS	0,4,2,2
	.STRING	18.,'-
	.BYTE	'+,LF,BS,'|,LF,BS,'+
	.STRING	8.,'-
	.BYTE	'>
	.EVEN
;
;	BRCLAR - ERASE LINE FROM BUFFER REGISTER TO ADDRESS REGISTER
;
GRPH41:	.WORD	GRPH42-.-2
	.POS	0,4,2,2
	.STRING	19.,SPACE
	.BYTE	LF,,BS,SPACE,LF,BS
	.STRING	10.,SPACE
	.EVEN
;
;	MUSKIP - SHOW TEXT BELOW ALU POS/ZERO OR NEG
;
GRPH42:	GRPH00-.-2
	.POS	2,1,1,9.
	.BYTE	'[
	.POS	2,1,2,4
	.BYTE	']
	.POS	2,2,1,9.
	.ASCII	/<: :>/
	.POS	2,2,1,9.
	.ASCII	/< : >/
	.POS	2,2,1,9.
	.ASCII	/<: :>/
	.POS	2,1,1,9.
	.BYTE	SPACE
	.POS	2,1,2,4
	.BYTE	SPACE
	.POS	2,2,1,9.
	.STRING	5,SPACE
	.EVEN
;
GRPH00:
;
;	C O N V E R S A T I O N A L   M E S S A G E S 
;
CMES01:	.WORD	CMES02-.-2
	.BYTE	ESC,'[,'H,ESC,'[,'J	;HOME AND CLEAR SCREEN
	.POS	0,8.,3,3
	.ASCII	/Welcome to the/
	.POS	1,0,2,9.
	.ASCII	/introduction computer/
	.POS	1,2,3,1.
	.ASCII	/from DEC Education/
	.POS	1,4,2,8.
	.ASCII	/Utrecht, The Netherlands/
	.EVEN
;
CMES02:	.WORD	CMES03-.-2
	.POS	2,0,0,1.
	.BYTE	ESC,'[,'J		;CLEAR SCREEN
	.ASCII	#Load program, Execute, Help or Quit (L/E/H/Q)? : #
	.EVEN
;
CMES03:	.WORD	CMES04-.-2
	.POS	2,0,0,1
	.BYTE	ESC,'[,'J
	.ASCII	#Do you want to change the way of executing (Y/N)? : #
	.EVEN
;
CMES04:	.WORD	CMES05-.-2
	.POS	2,0,0,1
	.BYTE	CR,LF
	.ASCII	#Time-pause choice : Nowait, Autostep or Userstep (N/A/U)? : #
	.EVEN
;
CMES05:	.WORD	CMES06-.-2
	.POS	2,0,0,1
	.BYTE	ESC,'[,'J
	.ASCII	/Pause between instructions /
	.EVEN
;
CMES06:	.WORD	CMES07-.-2
	.POS	2,0,0,1
	.BYTE	ESC,'[,'J
	.ASCII	/Pause between micro instructions /
	.EVEN
;
CMES07:	.WORD	CMES08-.-2
	.POS	2,0,0,1
	.BYTE	ESC,'[,'J
	.ASCII	#Register read out in Octal or Binary (O/B)? : #
	.EVEN
;
CMES08:	.WORD	CMES09-.-2
	.POS	2,0,0,1
	.CLIN
	.ASCII	/What is the (octal) load address of your program or data? : /
	.EVEN
;
CMES09:	.WORD	CMES10-.-2
	.POS	2,0,0,1
	.BYTE	ESC,'[,'J
	.ASCII	#Are you satisfied with your answers (Y/N/Q)? : #
	.EVEN
;
CMES10:	.WORD	CMES11-.-2
	.POS	2,0,0,1
	.BYTE	ESC,'[,'J
	.ASCII	/Please fill in the octal value of your program /
	.ASCII	/behind the address./
	.BYTE	CR,LF
	.ASCII	/If you have loaded the last value, then you can type: END/
	.BYTE	CR,LF
	.ASCII	/to end the loading process./
	.POS	2,4,3,5
	.EVEN
;
CMES11:	.WORD	CMES12-.-2
	.POS	2,4,1,3
	.ASCII	#Did you push a wrong key, did you make a mistake (Y/N)? : #
	.BYTE	ESC,'[,'1,'A
	.EVEN
;
CMES12:	.WORD	CMES13-.-2
	.POS	2,0,0,1
	.BYTE	ESC,'[,'J
	.ASCII	/Starting (octal) address of your program? : /
	.EVEN
;
CMES13:	.WORD	CMES14-.-2
	.POS	2,0,0,1
	.BYTE	ESC,'[,'J
	.ASCII	/First (octal) address of visible memory? : /
	.EVEN
;
CMES14:	.WORD	CMES15-.-2
	.BYTE	CR,LF
	.ASCII	/Number of ticks of 20msec, (octal)? : /
	.EVEN
;
CMES15:	.WORD	CMES16-.-2
	.POS	2,2,5,0
	.ASCII	/HALT/
	.POS	2,4,3,3
	.ASCII	#Go on or back to console (G/C)? : #
;	.BYTE	ESC,'[,'1,'A
	.EVEN
;
CMES16:	.WORD	CMES17-.-2
	.POS	1,7,4,1
	.STRING	4.,'?
	.POS	2,3,1,4
	.ASCII	/ILLEGAL INSTRUCTION!/
	.POS	2,4,1,4
	.STRING	56.,'?
;	.BYTE	ESC,'[,'1,'A
	.EVEN
;
CMES17:	.WORD	CMES18-.-2
	.POS	2,4,4,0
	.ASCII	/Non existing memory address/
	.BYTE	ESC,'[,'1,'A
	.EVEN
;
CMES18:	.WORD	CMES19-.-2
	.BYTE	ESC,'[,'H,ESC,'[,'J	;CLEAN SCREEN.
	.POS	0,1,2,1
	.ASCII	/M E M O R Y   C O N T E N T S/
	.POS	0,1,6,6
	.ASCII	/#CONSOLE MODE#/
	.BYTE	CR,LF
	.REPT	7.
	.ASCII	/ ADDR CONT /
	.ENDR
	.EVEN
;
CMES19:	.WORD	CMES20-.-2
	.BYTE	CR,LF
	.ASCII	#Do you want to draw lines with delay (Y/N)? : #
	.EVEN
;
CMES20:	.WORD	CMES21-.-2
	.POS	2,0,0,1
	.BYTE	ESC,'[,'J
	.ASCII	#Do you want micro-step subtitles during the run (Y/N)? : #
	.EVEN
;
CMES21:	.WORD	CMES22-.-2
	.POS	2,0,0,1
	.BYTE	ESC,'[,'J
	.ASCII	#Do you want data-flow lines drawn? (Y/N)? : #
	.EVEN
;
CMES22:	.WORD	CMES23-.-2
	.BYTE	ESC,'[,'H,ESC,'[,'J
	.ASCII	/You are connected to the intro-computer./
	.BYTE	CR,LF
	.ASCII	/This is a processor, from which the heart is laid open /
	.ASCII	/and made visible during/
	.BYTE	CR,LF
	.ASCII	/the run. In executing your program it is possible/
	.ASCII	/to follow the flow of data/
	.BYTE	CR,LF
	.ASCII	/between memory and registers./
	.BYTE	CR,LF
	.ASCII	/The computer always works in one of the following states :/
	.BYTE	CR,LF
	.POS	0,6,1,0
	.ASCII	/1.: console mode/
	.POS	0,7,1,0
	.ASCII	/2.: run or execute mode/
	.BYTE	CR,LF
	.ASCII	/In console mode, it is possible to load the computer /
	.ASCII	/memory with your program/
	.BYTE	CR,LF
	.ASCII	/and data. When the loading process is ready, you can execute/
	.ASCII	/your program./
	.BYTE	CR,LF
	.ASCII	/It is possible to make changes in the way your program /
	.ASCII	/will be executed./
	.BYTE	CR,LF
	.ASCII	/The main memory of consists of 157 words. Only 21 words /
	.ASCII	/are shown during the/
	.BYTE	CR,LF
	.ASCII	/execution of your program./
	.ASCII	/You can say where to start with these 21 visible words. /
	.BYTE	CR,LF
	.ASCII	/it is also possible to choose/
	.ASCII	/how the execution of your program can be delayed./
	.BYTE	CR,LF
	.ASCII	/Thereby is N: no delay, A: delay with a number of /
	.ASCII	/stops of 20 msec, and U: the/
	.BYTE	CR,LF
	.ASCII	/computer will halt until you have understood /
	.ASCII	/what was happening./
	.BYTE	CR,LF
	.ASCII	/Then you can push the space-bar and the next action /
	.ASCII	/will take place./
	.BYTE	CR,LF
	.ASCII	/This is possible between the instructions and /
	.ASCII	/between the micro-steps./
	.BYTE	CR,LF
	.ASCII	/Memory organisation: 12 bit words./
	.POS	2,1,1,3.
	.ASCII	/Instruction-set of computer : >>>/
	.POS	1,9.,4,7
	.ASCII	/1XXX = ADD  6XXX = STRI /
	.POS	2,0,4,7
	.ASCII	/2XXX = ISZ  7001 = IAC  7440 = SIZ/
	.POS	2,1,4,7
	.ASCII	/3XXX = STR  7040 = CMA  7500 = SIM/
	.POS	2,2,4,7
	.ASCII	/4XXX = ADDI 7200 = CLA  7510 = SIP/
	.POS	2,3,4,7
	.ASCII	/5XXX = JMP  7402 = HLT/
	.POS	2,4,0,1
	.ASCII	/Push space-bar to continue/
	.BYTE	ESC,'[,'1,'A	;ONE UP.
	.EVEN
;
CMES23:	.WORD	CMES24-.-2
	.BYTE	ESC,'[,'H,ESC,'[,'J
	.POS	1,0,3,5
	.ASCII	/P O W E R/
	.POS	1,1,3,7
	.ASCII	/O F F/
	.EVEN
;
CMES24:	.WORD	CMES25-.-2
	.POS	2,1,2,0
	.ASCII	/ZERO/
	.EVEN
;
CMES25:	.WORD	CMES26-.-2
	.POS	2,1,2,0
	.ASCII	/POS /
	.EVEN
;
CMES26:	.WORD	CMES27-.-2
	.POS	2,1,2,0
	.ASCII	/NEG /
	.EVEN
;
CMES27:	.WORD	CMES28-.-2
	.POS	2,3,5,3
	.ASCII	/YES!/
	.EVEN
;
CMES28:	.WORD	CMES29-.-2
	.POS	2,3,5,3
	.ASCII	/NO!/
	.EVEN
;
CMES29:	.WORD	CMES00-.-2
	.POS	2,4,3,5
	.EVEN
;
CMES00:
;
;
;	M I C R O   I N S T R U C T I O N   F I E L D
;
MFETCH:	.WORD	GOFETC,IRCLDC,PCTOAR
	.WORD	ARTOME,MMREAD,METOBR
	.WORD	BRTOIR,PCCLAR,ARCLME
	.WORD	MMCLAD,MECLBR,BRCLIR
	.WORD	PCPLON,PCCLON,GOEXEC
	.BYTE	IRTODC,201	;GO TO EXECUTE TABLE.
;
MSERVC:	.BYTE	SERVIC,200	;GO TO FETCH STATE.
	.WORD	MFETCH
;
;	ADD MICRO
MEX01:	.WORD	IRTOAR,ARTOME,MMREAD
	.WORD	METOBR,ACTOAL,BRTOAL
	.WORD	EXEALU,ALTOAC,IRCLAR
	.WORD	ARCLME,MMCLAD,MECLBR
	.WORD	ACCLAL,BRCLAL
	.BYTE	ALCLAC,202	;GO TO SERVICE STATE.
;
;	ISZ MICRO
MEX02:	.WORD	IRTOAR,ARTOME,MMREAD
	.WORD	METOBR,BRTOAL,EXEALU
	.WORD	ALTOBR,MMCLAD,MECLBR
	.WORD	BRTOME,MMWRIT,IRCLAR
	.WORD	ARCLME,MMCLAD,BRCLME
	.WORD	BRCLAL,ALCLBR
	.BYTE	MUSKIP,203	;SKIP CONDITION?
	.WORD	MEX02A		;SKIP ADDRESS MICRO
;NOTE : JUMP OVER IF NO SKIP CONDITION.
	.BYTE	ARCLME,202	;GO TO SERVICE STATE.
MEX02A:	.WORD	PCPLON
	.BYTE	PCPLON,202	;GO TO SERVICE STATE.
;
;	STR MICRO
MEX03:	.WORD	IRTOAR,ARTOME,ACTOBR
	.WORD	BRTOME,MMWRIT,IRCLAR
	.WORD	ARCLME,ACCLBR,BRCLME
	.BYTE	MMCLIT,200	;GO TO CLA MICRO.
	.WORD	MEX07
;
;	JMP MICRO
MEX04:	.WORD	IRTOPC
	.BYTE	IRCLPC,202	;GO TO SERVICE STATE.
;
;	IAC MICRO
MEX05:	.WORD	ACTOAL,EXEALU,ALTOAC
	.WORD	ACCLAL
	.BYTE	ALCLAC,202	;GO TO SERVICE STATE.
;
;	CMA MICRO
MEX06:	.BYTE	ALCLAC,200	;CMA COMMON ROUTINE.
	.WORD	MEX05
;
;	CLA MICRO
MEX07:	.WORD	ACCUCL
	.BYTE	ACCLCL,202	;GO TO SERVICE STATE.
;
;	HLT MICRO
MEX08A:	.WORD	BRCLME,BRCLAR
	.WORD	ACCLBR,PCCLAR
	.WORD	ARCLME,IRCLAR
	.WORD	MMCLAD
MEX08:	.BYTE	GOHALT,204	;GO TO HALT STATE.
;
;	ADD INDIRECT MICRO
MEX09:	.WORD	IRTOAR,ARTOME,MMREAD
	.WORD	METOBR,IRCLAR,ARCLME
	.WORD	MMCLAD,MECLBR,BRTOAR
	.WORD	ARTOME,MMREAD,BRCLAR
	.WORD	METOBR,ARCLME,MMCLAD
	.WORD	BRTOAL,ACTOAL,EXEALU
	.WORD	ALTOAC,MECLBR,BRCLAL
	.WORD	ACCLAL
	.BYTE	ALCLAC,202	;GO TO SERVICE STATE.
;
;	STORE INDIRECT MICRO
MEX10:	.WORD	IRTOAR,ARTOME,MMREAD
	.WORD	METOBR,IRCLAR,ARCLME
	.WORD	MMCLAD,MECLBR,BRTOAR
	.WORD	ARTOME,BRCLAR,ACTOBR
	.WORD	BRTOME,MMWRIT,ACCLBR
	.WORD	MMCLIT,BRCLME,BRCLAR
	.BYTE	ARCLME,200	;GO TO CLA MICRO.
	.WORD	MEX07
;
;	SKIP IF ZERO
MEX11:
;
;	SKIP IF MINUS
MEX12:
;
;	SKIP IF POSITIVE
MEX13:	.BYTE	MUSKIP,203
	.WORD	MEX02A
	.BYTE	IRCLDC,202	;GO TO SERVICE STATE.
;
;	DECODER INSTRUCTION TEXT
;
DIM01:	.WORD	DIM02-.-2
	.POS	1,7,4,1
	.ASCII	/ADD /
	.EVEN
;
DIM02:	.WORD	DIM03-.-2
	.POS	1,7,4,1
	.ASCII	/ISZ /
	.EVEN
;
DIM03:	.WORD	DIM04-.-2
	.POS	1,7,4,1
	.ASCII	/STR /
	.EVEN
;
DIM04:	.WORD	DIM05-.-2
	.POS	1,7,4,1
	.ASCII	/JMP /
	.EVEN
;
DIM05:	.WORD	DIM06-.-2
	.POS	1,7,4,1
	.ASCII	/IAC /
	.EVEN
;
DIM06:	.WORD	DIM07-.-2
	.POS	1,7,4,1
	.ASCII	/CMA /
	.EVEN
;
DIM07:	.WORD	DIM08-.-2
	.POS	1,7,4,1
	.ASCII	/CLA /
	.EVEN
;
DIM08:	.WORD	DIM09-.-2
	.POS	1,7,4,1
	.ASCII	/HLT /
	.EVEN
;
DIM09:	.WORD	DIM10-.-2
	.POS	1,7,4,1
	.ASCII	/ADDI/
	.EVEN
;
DIM10:	.WORD	DIM11-.-2
	.POS	1,7,4,1
	.ASCII	/STRI/
	.EVEN
;
DIM11:	.WORD	DIM12-.-2
	.POS	1,7,4,1
	.ASCII	/SIZ /
	.EVEN
;
DIM12:	.WORD	DIM13-.-2
	.POS	1,7,4,1
	.ASCII	/SIM /
	.EVEN
;
DIM13:	.WORD	DIM99-.-2
	.POS	1,7,4,1
	.ASCII	/SIP /
	.EVEN
;
DIM99:	.WORD	DIM00-.-2
	.POS	1,7,4,1
	.ASCII	/????/
	.EVEN
DIM00:
;
;	INSTRUCTION MESSAGES
;
INT01:	.WORD	INT02-.-2
	.POS	2,3,1,4
	.ASCII	/ADD : add accu to memory/
	.EVEN
;
INT02:	.WORD	INT03-.-2
	.POS	2,3,1,4
	.ASCII	/ISZ : increment memory location, skip?/
	.EVEN
;
INT03:	.WORD	INT04-.-2
	.POS	2,3,1,4
	.ASCII	/STR : put accumulator value into memory/
	.EVEN
;
INT04:	.WORD	INT05-.-2
	.POS	2,3,1,4
	.ASCII	/JMP : jump to the given address/
	.EVEN
;
INT05:	.WORD	INT06-.-2
	.POS	2,3,1,4
	.ASCII	/IAC : increment the accumulator by one/
	.EVEN
;
INT06:	.WORD	INT07-.-2
	.POS	2,3,1,4
	.ASCII	/CMA : complement/
	.EVEN
;
INT07:	.WORD	INT08-.-2
	.POS	2,3,1,4
	.ASCII	/CLA : clear the accumulator/
	.EVEN
;
INT08:	.WORD	INT09-.-2
	.POS	2,3,1,4
	.ASCII	/HLT : stop the processor/
	.EVEN
;
INT09:	.WORD	INT10-.-2
	.POS	2,3,1,4
	.ASCII	/ADDI : add with indirect address mode/
	.EVEN
;
INT10:	.WORD	INT11-.-2
	.POS	2,3,1,4
	.ASCII	/STRI : transfer accu data to memory with indirect /
	.ASCII	/addressing mode/
	.EVEN
;
INT11:	.WORD	INT12-.-2
	.POS	2,3,1,4
	.ASCII	/SIZ : ZERO? skip one instruction....../
	.EVEN
;
INT12:	.WORD	INT13-.-2
	.POS	2,3,1,4
	.ASCII	/SIM : NEG? skip one instruction......./
	.EVEN
;
INT13:	.WORD	INT00-.-2
	.POS	2,3,1,4
	.ASCII	/SIP : POS? skip one instruction......./
	.EVEN
;
INT00:
;
GMSG01:	.POS	2,2,5,0
	.ASCII	/wait/
	.EVEN
;
GMSG02:	.POS	2,2,5,0
	.ASCII	/run /
	.EVEN
;
;	MICRO-STEP LOOKUP TABLES
;
;	EXECUTION SEQUENCE FOR INSTRUCTIONS
;	
MEXTAB:	.WORD	MEX01,MEX02,MEX03,MEX04
	.WORD	MEX05,MEX06,MEX07,MEX08
	.WORD	MEX09,MEX10,MEX11,MEX12
	.WORD	MEX13
;
;	GRAPHIC SEQUENCE
;
GRPTAB:	.WORD	GRPH01,GRPH02,GRPH03,GRPH04
	.WORD	GRPH05,GRPH06,GRPH07,GRPH08
	.WORD	GRPH09,GRPH10,GRPH11,GRPH12
	.WORD	GRPH13,GRPH14,GRPH15,GRPH16
	.WORD	GRPH17,GRPH18,GRPH19,GRPH20
	.WORD	GRPH21,GRPH22,GRPH23,GRPH24
	.WORD	GRPH25,GRPH26,GRPH27,GRPH28
	.WORD	GRPH29,GRPH30,GRPH31,GRPH32
	.WORD	GRPH33,GRPH34,GRPH35,GRPH36
	.WORD	GRPH37,GRPH38,GRPH39,GRPH40
	.WORD	GRPH41,GRPH42
;
;	DISPLAY MESSAGE
;
COMTAB:	.WORD	MES01,MES02,MES03,MES04
	.WORD	MES05,MES06,MES07,MES08
	.WORD	MES09,MES10,MES11,MES12
	.WORD	MES13,MES14,MES15,MES16
	.WORD	MES17,MES18,MES19,MES20
	.WORD	MESCL,MESCL,MESCL,MESCL
	.WORD	MESCL,MESCL,MESCL,MESCL
	.WORD	MESCL,MESCL,MESCL,MESCL
	.WORD	MESCL,MESCL,MESCL,MESCL
	.WORD	MES37,MESCL,MES39,MES40
	.WORD	MESCL,MES42
;
;	ACTION
;
ACTTAB:	.WORD	ACT01,ACT02,ACT03,ACT04
	.WORD	ACT05,ACT06,ACT07,ACT08
	.WORD	ACT09,ACT10,ACT11,ACT12
	.WORD	ACT13,ACT14,ACT15,ACT16
	.WORD	ACT17,ACT18,ACT19,ACT20
	.WORD	ACTNO,ACTNO,ACTNO,ACTNO
	.WORD	ACTNO,ACTNO,ACTNO,ACTNO
	.WORD	ACTNO,ACTNO,ACTNO,ACTNO
	.WORD	ACTNO,ACTNO,ACTNO,ACTNO
	.WORD	ACT37,ACTNO,ACT39,ACT40
	.WORD	ACTNO,ACT42
;
;	ALU EXECUTION FLOW
;
ALXTAB:	.WORD	ACT201,ACT202,ACT203,ACT204
	.WORD	ACT205,ACT206,ACT207,ACT208
	.WORD	ACT209,ACT210,ACT211,ACT212
	.WORD	ACT213
;
;	DECODER INSTRUCTION MESSAGE
;
DIMTAB:	.WORD	DIM01,DIM02,DIM03,DIM04
	.WORD	DIM05,DIM06,DIM07,DIM08
	.WORD	DIM09,DIM10,DIM11,DIM12
	.WORD	DIM13,DIM99		;ILLEGAL
;
;	INSTRUCTION MESSAGES
;
INTTAB:	.WORD	INT01,INT02,INT03,INT04
	.WORD	INT05,INT06,INT07,INT08
	.WORD	INT09,INT10,INT11,INT12
	.WORD	INT13
;
;	INSTRUCTIONS
;
INSTAB:	.WORD	1000	;ADD	1
	.WORD	2000	;ISZ	2
	.WORD	3000	;STR	3
	.WORD	5000	;JMP	4
	.WORD	7001	;IAC	5
	.WORD	7040	;CMA	6
	.WORD	7200	;CLA	7
	.WORD	7402	;HLT	8
	.WORD	4000	;ADD I	9
	.WORD	6000	;STR I	10
	.WORD	7440	;SIZ	11
	.WORD	7500	;SIM	12
	.WORD	7510	;SIP	13
INSTAE:			;END OF TABLE
;
;	I N T E R N A L   R E G I S T E R S 
;
IAC:	.WORD	0		;ACCUMULATOR
IAL:	.WORD	0		;ARITHMETIC UNIT OUTPUT
IALA:	.WORD	0		;ARITHMETIC UNIT INPUT 'A'
IALB:	.WORD	0		;ARITHMETIC UNIT INPUT 'B'
IAR:	.WORD	0		;ADDRESS REGISTER
IBR:	.WORD	0		;BUFFER REGISTER
IIR:	.WORD	0		;INSTRUCTION REGISTER
IPC:	.WORD	0		;PROGRAM COUNTER
IMEM:	.BLKW	224.		;MEMORY SPACE
IMEMVL:	.WORD	0		;LOW BOUNDARY VISIBLE MEMORY
IMEMVH:	.WORD	21.		;HIGH BOUNDARY VISIBLE MEMORY
IINDEX:	.WORD	0		;INSTRUCTION INDEX WORD
MICA:	.BYTE	ESC,'[,'1,'A	;CURSOR 1 UP
MICPC:	.WORD	MFETCH		;MICRO PROGRAM COUNTER
CONDZE:	.WORD	0		;CONDITION REGISTER
				;  BIT 0 IS USED AND IS ZERO BIT
				;  BIT 1 IS USED AND IS MINUS BIT
;
;	TIME / PAUSE MODE
;	0 = NOWAIT, FAST EXECUTION
;	1 = AUTO STEP, DELAYED WITH FIXED PAUSE
;	2 = USER STEP, STEPS ACCORDING TO THE USER
;
SEQMOD:	.WORD	1		;AUTO STEP PRESET FOR MICO INSTRUCTIONS
	.WORD	500		;PRESET WAITLOOP OF 20MSEC TICKS
ISQMOD:	.WORD	2		;USER STEP FOR INSTRUCTIONS
	.WORD	0		;PRESET USER SET DELAY TICKS
MESENB:	.WORD	1		;ENABLE MESSAGES
GRENB:	.WORD	1		;ENABLE GRAPHICS BY USER
GRQENB:	.WORD	0		;ENABLE DELAY FOR GRAPHICS BY MICRO-PROG.
GRQMOD:	.WORD	0		;DELAY MODE BY USER
	.WORD	1		;20 MSEC TICKS
BOUT:	.BLKB	2200.		;OUTPUT BUFFER
COCBA:	.WORD	0		;1=WRONG, 0=RIGHT NUMBER OF OCTALS.
GENBF:	.WORD	0,0		;FLAG
GENBUF:	.BLKW	40.		;GENERAL BUFFER
IOST:	.WORD	0,0		;DETECT KEYBOARD USAGE (N.U.)
IOSTAT:	.WORD	0,0		;QIOW$S IO STATUS BLOCK
OCBINR:	.WORD	0		;DISPLAY REGISTER MODE, 0 = OCTAL, 1 = BINARY
OLDVL:	.WORD	0		;OLDEST LOW MEMORY BOUNDARY
OLDVH:	.WORD	21.		;OLDEST HIGH MEMORY BOUNDARY
OUTAA:	.BYTE	CR,0		;MSG
OUTAB:	.WORD	0,0		;MSG
TIME:	.WORD	0,0		;STORED CURRENT DELAY TIME
TMPX:	.WORD	0		;USED FOR X
TMPY:	.WORD	0		;USED FOR Y

	.END	START		;END OF VERY LONG PROGRAM!!!
