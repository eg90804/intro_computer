;
;	PROGRAM, DESIGNED FOR THE INTRODUCTION TO MINICOMPUTERS COURSE,
;	TO SHOW HOW AN INSTRUCTION IS EXECUTED IN THE HART OF THE CPU
;	OF A PDP-8 LIKE PROCESSOR
;	WRITTEN BY JAN POSTHUMA, TRAINING UTRECHT HOLLAND
;	DATE 1 NOVEMBER 1978
;	PRELIMINARY RELEASE
;	TRANSLATED INTO ENGLISH BY DICK BIESBOER, TRAINING UTRECHT
;	DATE 7 JANUARY 1980
;	THIS SIMULATION PROCESSOR IS DESCRIBED IN THE MODULE
;	"CENTRAL PROCESSOR" IN PART 5 OF THE INTRODUCTION TO
;	MINICOMPUTERS COURSE.
;
	.TITLE	CPU
;
	.MCALL EXIT$S, QIOW$S, MRKT$S, WTSE$S
;
;	SOME MACROS TO SPECIFY ASCII FIELDS
;
;	MACRO TO DRAW A STRING OF CHARACTERS TO THE RIGHT;
;
	.MACRO	.STRING,.NUM,.CHAR
	.REPT	.NUM
	.BYTE	.CHAR
	.ENDR
	.ENDM
;
;	MACRO TO POSITION THE CURSOR.
;
	.MACRO	.POS,.LINE,.COLUMN	;POSITION MACRO
	.BYTE	ESC,131			;ESCAPE Y
	.BYTE	.LINE+037
	.BYTE	.COLUMN+037
	.ENDM
;
;	MACRO TO DRAW A REGISTER.
;
	.MACRO	.REG,.UD,.LEFT,.RIGHT
	.STRING	16.,.UD
	.STRING	16.,BS
	.BYTE	LF,.LEFT,BS,LF
	.STRING	16.,.UD
	.BYTE	BS,ESC,'A		; MOVE UP
	.BYTE	.RIGHT
	.ENDM
;
;	MACRO TO DRAW A STRING DOWNWARDS.
;
	.MACRO	.DOWN,.NUN,.CHR
	.REPT	.NUN
	.BYTE	.CHR
	.BYTE	LF,BS
	.ENDR
	.ENDM
;
;	MACRO TO DRAW A STRING UPWARDS.
;
	.MACRO	.UP,.NM,.CH
	.REPT	.NM
	.BYTE	.CH
	.BYTE	BS,ESC,'A
	.ENDR
	.ENDM
;
;	MACRO TO DRAW A STRING TO THE LEFT.
	.MACRO	.LEF,.NUUM,.CHAAR
	.REPT	.NUUM
	.BYTE	.CHAAR
	.BYTE	BS,BS
	.ENDR
	.ENDM
;
;	MACRO TO CLEAR A LINE.
;
	.MACRO	.CLIN
	.BYTE	ESC,'K
	.ENDM
;
;	MACRO TO PUT REPEATEDLY A WORD IN A TABLE.
;
	.MACRO	.RPEAT,.MUN,.WOOORD
	.REPT	.MUN
	.WORD	.WOOORD
	.ENDR
	.ENDM
;
;	DIRECT ASSIGNMENTS
;X X X X X X X X X X X X X X X X X X X X X X X X X X X X
	ESC=033
	SPACE=040
	BS=010
	LF=012
	CR=015
	BEL=007
	JSW=44
	MEMTOP=104.		; 150 OCTAL.
;
;	M I C R O  I N S T R U C T I O N S
;. . . . . . . . . . . . . . . . . . . . . . . . . . . .
	BRTOME=1
	BRTOAL=2
	ACTOAL=3
	ALTOAC=4
	ACTOBR=5
	BRTOIR=6
	IRTODC=7
	IRTOPC=8.
	PCTOAR=9.
	ARTOME=10.
	IRTOAR=11.
	PCPLON=12.
	METOBR=13.
	MMREAD=14.
	MMWRIT=15.
	ACCUCL=16.
	SERVIC=17.
	GOFETC=18.
	GOEXEC=19.
	EXEALU=20.
	BRCLME=21.
	BRCLAL=22.
	ACCLAL=23.
	ALCLAC=24.
	ACCLBR=25.
	BRCLIR=26.
	IRCLDC=27.
	IRCLPC=28.
	PCCLAR=29.
	ARCLME=30.
	IRCLAR=31.
	PCCLON=32.
	MECLBR=33.
	MMCLAD=34.
	MMCLIT=35.
	ACCLCL=36.
	ALTOBR=37.
	ALCLBR=38.
	GOHALT=39.
	BRTOAR=40.
	BRCLAR=41.
	MUSKIP=42.

START:	CLR	GRQENB		;DISABLE GRAPHIC DELAY AT START.
	BR	RSTART

RSTART:	JSR	R5,OUT		;WELCOME MESSAGE
RST1:	.WORD	IMES1,0
	JSR	R5,WAIT		;WAIT 3 SECONDS
	.WORD	0,150.
RST1A:
	JSR	R5,SHOMEM	;SHOW MEMORY CONTENTS.
	.WORD	1		;CLEAN SCREEN
RST1B:
	JSR	R5,OUT
RST2:	.WORD	IMES2,0		;NO CLEAN SCREEN.
RST2A:	JSR	R5,IN
	.WORD	1		;ASK FOR INPUT
	CMPB	GENBUF,#'L
	BNE	RST3		;NO LOAD
	JMP	RST4
RST3:	CMPB	GENBUF,#'H	;HELP????
	BNE	RST3C
	JSR	R5,OUT
	.WORD	IMES22,0
	JSR	R5,IN
	.WORD	1		;WAIT UNTIL READ
	JMP	RSTART		;RESTART AGAIN
RST3C:	CMPB	GENBUF,#'Q	;EXIT???
	BNE	RST3A
	JSR	R5,OUT		;DISPLAY POWER OFF.
	.WORD	IMES23,0
	JSR	R5,WAIT		;WAIT 2 SECONDS
	.WORD	0,100.
	JSR	R5,OUT		;CLEAR SCREEN
	.WORD	IMES23+2,4
	JSR	R5,OUT		;SET TT VT100
	.WORD	IMES30,0
;	JSR	R5,WAIT		;WAIT 5 SEC FOR EXIT
;	.WORD	0,250.
	EXIT$S			;STOP IT.
RST3A:	CMPB	GENBUF,#'E
	BEQ	RST6		;EXECUTE
RST5:
	BR	RST1B
RST6:
	JSR	R5,OUT		;NORMAL OR SPECIAL?
RST7:	.WORD	IMES3,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'N
	BNE	RST8		;NOT NORMAL
	JMP	RST9
RST8:	CMPB	GENBUF,#'Y
	BNE	RST6		;NOT SPECIAL.
	JMP	RST11
RST9:				;ASK FOR START ADDRESS.
	JSR	R5,OUT
RST12:	.WORD	IMES12,0
	JSR	R5,IN
	.WORD	4
				;FORMATTED INPUT.
	MOV	IOSTAT+2,RST13+2;LENGTH
	BEQ	RST9
	JSR	R5,COCBIN	;CONVERT OCTAL TO BINARY.
RST13:	.WORD	GENBUF,4,0
	TST	COCBA		;FALSE?
	BNE	RST9		;YES!!!
	MOV	RST13+4,IPC	;TO PC
;
;	PROGRAM IS NOW LOADED.
;	GRAPHICS CAN BE PRINTED.
;	MEMORY AND PROGRAM COUNTER ARE DISPLAYED.
;
	JSR	R5,OUT
RST14:	.WORD	SETRAS,0
	MOV	IMEMVL,R3	;LOWER MEMORY BOUNDARY TO R3.
	MOV	#40,R1		;FIRST POSITION IN R1.
RST14A:
	MOVB	R1,RST15+4	;POSITION.
	MOV	R3,R2
	ASL	R2
	ADD	#IMEM,R2	;MAKE REAL ADDRESS.
	MOV	R2,RST15
	MOV	R3,IAR		;IAR TO SHOW ADDRESS.
	JSR	R5,DISMEM	;DISPLAY MEMORY.
RST15:	.WORD	0
	.POS	1,72.
	INC	R1		;INCREMENT POSITION SCREEN.
	INC	R3		;GO TO NEXT POSITION.
	CMP	R3,IMEMVH	;END OF MEMORY BLOCK?
	BNE	RST14A
;
;	DISPLAY ACCUMULATOR.
;
	JSR	R5,DISREG
	.WORD	IAC
	.POS	11.,5
;
;	DISPLAY CONDITION REGISTER.
;
	JSR	R5,DISCON
;
;	DISPLAY PROGRAM COUNTER.
;
RST15A:	JSR	R5,DISREG
	.WORD	IPC
	.POS	17.,52.
;
;	OPEN INPUT FOR KEYBOARD
;
	CLR	IOST
;
;	PUT MICRO P.C. ON START OF MICROCODE.
;
	MOV	#MFETCH,MICPC
	MOV	#MICENT,R5	;JUMP IN THE MIDDLE OF SUBROUTINE.
	MOV	R5,-(SP)
	JMP	TIMS2		;WAIT FOR USER SPACE.
GENBF:	.WORD	0,0
IOST:	.WORD	0,0
;
;	PROGRAM LOAD ROUTINE.
;
RST4:				;ASK FOR LOAD ADDRESS.
	JSR	R5,OUT
RST16:	.WORD	IMES8,0
	MOV	#1,GENBF	;MARK FLAG FOR FIRST TIME.
	JSR	R5,IN
	.WORD	4
	MOV	IOSTAT+2,RST17+2;LENGTH.
	BEQ	RST4
	JSR	R5,COCBIN	;CONVERT OCTAL TO BINARY
RST17:	.WORD	GENBUF,4,0
	TST	COCBA
	BNE	RST4		;FALSE OC'S.
	MOV	RST17+4,IAR	;PUT IN ADDRESS REGISTER.
RST17A:
	TST	GENBF		;FIRST TIME?
	BEQ	RST17B		;NO
	JSR	R5,OUT
	.WORD	IMES10,0
RST18:	JSR	R5,CBINOC	;CONVERT BINARY TO OCTAL.
RST19:	.WORD	IAR,0,0
	CLR	GENBF		;MARK FLAG FOR FIRST TIME.
	MOV	#ESC,GENBUF	;CLEAR LINE FIRST
	MOVB	#'K,GENBUF+1	;BEFORE WRITING.
	MOV	RST19+2,GENBUF+2;OCTAL VALUE.
	MOV	RST19+4,GENBUF+4
	MOV	#SPACE,GENBUF+6
	MOVB	#SPACE,GENBUF+7	;ADD SPACE.
	JSR	R5,OUT
	.WORD	GENBUF,8.
	JSR	R5,IN
	.WORD	4
	CMP	GENBUF,#"EN	;LAST?
	BNE	RST21
	JMP	RST1B		;BACK TO START.
RST17B:	JSR	R5,OUT		;CURSOR IN RIGHT POSITION 23.,1
	.WORD	IMES29,0
	JMP	RST18
RST21:	MOV	IOSTAT+2,RST22+2;LENGTH.
	BEQ	RST22C
	JSR	R5,COCBIN	;CONVERT OCTAL TO BINARY.
RST22:	.WORD	GENBUF,4,0
	TST	COCBA		;FALSE?
	BNE	RST17A
	CMP	IAR,#MEMTOP	;NORMAL AREA OF MEMORY?
	BLOS	RST22B		;NOT EXISTING.
	JSR	R5,OUT		;SHOW ERROR
	.WORD	IMES17,0
	JSR	R5,WAIT
	.WORD	0,50.		; WAIT A SECOND.
	JMP	RST4
RST22B:	
	MOV	IAR,R0		;FIRST CONVERT
	ASL	R0		;MAKE BYTE ADDRESS
	ADD	#IMEM,R0	;TO REAL MEMORY.
	MOV	RST22+4,(R0)	;STORE IN MEMORY.
	JSR	R5,SHOMEM	;SHOW MEMORY AGAIN.
	.WORD	-1.		;NO CLEAN SCREEN, AND ONLY ONE WORD.
RST22A:
	INC	IAR		;GO TO THE NEXT.
	BIC	#170000,IAR	;REMOVE HIGHEST BITS.
	JMP	RST17A		;AND READ THE NEXT.
RST22C:
	CMPB	#CR,IOSTAT+1	;LOOK AT TERMINATING CHARACTER.
	BEQ	RST22A
	CMPB	#ESC,IOSTAT+1	;IS IT AN ESCAPE?????? THEN BACK.
	BEQ	RST22E
	JMP	RST17A		;NO INCREMENT.
RST22E:	DEC	IAR		;DECREMENT THE COUNTER.
	BIC	#170000,IAR
	JMP	RST17A
;
;	SPECIAL MODE OF EXECUTION.
;
RST11:
	MOV	IMEMVL,OUDVL	;KEEP THE OLD BOUNDARIES
	MOV	IMEMVH,OUDVH
	JSR	R5,OUT		;ASK FOR VISUAL START ADDRESS.
RST11B:	.WORD	IMES13,0
	JSR	R5,IN
	.WORD	4
	MOV	IOSTAT+2,RST11C+2;LENGTH.
	BEQ	RST11
	JSR	R5,COCBIN	;CONVERT OCTAL TO BINARY.
RST11C:	.WORD	GENBUF,4,0
	TST	COCBA		;FALSE OC'S?
	BNE	RST11
	CMP	RST11C+4,#124	;HIGHEST POSSIBLE ADDRESS?
	BHI	RST11
	CMP	RST11C+4,IMEMVL	;CHANGE IN VISUAL PART?
	BEQ	RST11D		;NO, THEN NO SCREEN REFRESH.
	MOV	RST11C+4,IMEMVL	;FIRST CHANGE THE BOUNDARY.
	MOV	IMEMVL,IMEMVH	;ALSO HIGH BOUNDARY.
	ADD	#21.,IMEMVH
	JSR	R5,SHOMEM	;YES, REFRESH SCREEN.
	.WORD	-2.		;NO, CLEAN AND ONLY DOTS.
RST11D:
	MOV	RST11C+4,IMEMVL	;LOAD LOWER MEMORY BOUNDARY.
	MOV	IMEMVL,IMEMVH
	ADD	#21.,IMEMVH	;HIGHEST POSITION.
RST11A:
	JSR	R5,OUT		;REG.DISPLAY OCTAL OR BINARY?
RST23:	.WORD	IMES7,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'O	;OCTAL?
	BEQ	RST24
	CMPB	GENBUF,#'B	;BINARY?
	BEQ	RST25
	BR	RST11A		;NOT KNOWN.
RST24:	CLR	OCBINR		;SET OCTAL
	BR	RST26
RST25:	MOV	#1,OCBINR	;SET BINARY.
RST26:	MOV	#-1.,IBR	;FLAG FOR TWO PAUSE QUESTIONS.
	JSR	R5,OUT
RST27:	.WORD	IMES5,0
RST26A:
	JSR	R5,OUT		;WHICH PAUSE MODE?
RST28:	.WORD	IMES4,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'N
	BEQ	RST29		;NOWAIT.
	CMPB	GENBUF,#'A
	BEQ	RST30		;AUTO STEP.
	CMPB	GENBUF,#'U
	BEQ	RST31		;USER STEP.
	BR	RST26A
RST29:	CLR	SEQMOD		;MAKE NOWAIT.
	BR	RST32
RST30:	MOV	#1,SEQMOD	;MAKE AUTO STEP
	JSR	R5,OUT		;ASK FOR NUMBER OF TICKS.
RST33:	.WORD	IMES14,0
	JSR	R5,IN
	.WORD	4
	MOV	IOSTAT+2,RST34+2
	BEQ	RST30
	JSR	R5,COCBIN	;CONVERT TO BINARY.
RST34:	.WORD	GENBUF,4,0
	TST	COCBA		;FALSE?
	BNE	RST30
	MOV	RST34+4,SEQMOD+2;NUMBER OF TICKS.
	BR	RST32
RST31:	MOV	#2,SEQMOD	;MAKE USER STEP
RST32:	INC	IBR
	BNE	RST35
	MOV	SEQMOD,ISQMOD	;FOR INSTRUCTIONS
	MOV	SEQMOD+2,ISQMOD+2;TRANSFER TICK.
	JSR	R5,OUT		;PAUSE BETWEEN INSTRUCTIONS?
RST36:	.WORD	IMES6,0
	JMP	RST26A		;GO BACK.
;
RST35:	JSR	R5,OUT		;ASK FOR SUBTITLES.
	.WORD	IMES20,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'Y	;YES.
	BEQ	RST35I
	CMPB	GENBUF,#'N	;NO.
	BNE	RST35		;NOT DONE WELL.
	CLR	MESENB		;DISABLE SUBTITLES.
	JMP	RST35J		;BACK TO SATISFIED?
RST35I:	MOV	#1,MESENB	;YES SUBTITLES.
RST35J:
	JSR	R5,OUT		;ASK FOR DRAWING LINES.
	.WORD	IMES21,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'Y	;YES
	BEQ	RST35L
	CMPB	GENBUF,#'N	;NO
	BNE	RST35J
	CLR	GRENB		;DISABLE LINE GRAPHICS
	JMP	RST35A
RST35L:	MOV	#1,GRENB	;ENABLE GRAPHICS
	BR	RST35G
RST35C:	CLR	GRQMOD		;NO DELAY
	JMP	RST35A
;
RST35G:
	JSR	R5,OUT		;ASK GRAPHICS DELAY
RST35B:	.WORD	IMES19,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'N	;NO DELAY?
	BEQ	RST35C
	CMPB	GENBUF,#'D	;DELAY?
	BNE	RST35G		;ASK AGAIN
	MOV	#1,GRQMOD	;MAKE IT DELAY MODE.
RST35F:
	JSR	R5,OUT
RST35D:	.WORD	IMES14,0
	JSR	R5,IN
	.WORD	4
	MOV	IOSTAT+2,RST35E+2;LENGTH.
	BEQ	RST35F
	JSR	R5,COCBIN	;CONVERT TO BINARY
RST35E:	.WORD	GENBUF,4,0
	TST	COCBA		;FALSE CONVERSION?
	BNE	RST35F		;YES.
	MOV	RST35E+4,GRQMOD+2;NUMBER OF TICKS.
;
;	ARE YOU SATISFIED NOW ? ? ? ? / ? / ? / ?
;
RST35A:
	JSR	R5,OUT		;SATISFIED?
RST38:	.WORD	IMES9,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'Y
	BNE	RST37
	JMP	RST9		;YES
RST37:	CMPB	GENBUF,#'N	;NO.
	BNE	RST35A
	JMP	RST1B
;
;
;	THE NEXT PART IS THE
;	M I C R O   C O D E   I N T E R P R E T E R
;	............................................
;
; MICRO INSTRUCTION LAYOUT :
;
;
;	BYTE 0 : MICRO INSTRUCTION ACTION.
;	BYTE 1 : MICRO JUMP DATA
;
;		THIS ONE HAS THE FOLLOWING POSSIBILITIES :
;
;		000	GO TO NEXT INSTRUCTION.
;		200	UNCONDITIONAL JUMP.
;			GO TO MICROADDRESS SHOWN BY NEXT MICRO-WORD.
;		201	JUMP ACCORDING TO INSTRUCTION COMPARED TO
;			EXECUTE ADDRESS TABLE.
;		202	GO TO SERVICE STATE.
;		203	SKIP NEXT MICROWORD IF CONDZE FITS SKIPCOMBINATION.
;		204	EXAMINE RUN STATE DURING HALT CONDITION.
;
;
;	MICRO PROGRAM COUNTER.
;
MICPC:	.WORD	MFETCH
MICA:	.BYTE	ESC,'A		;NO SCROLL.
MICENT:	MOV	@MICPC,R0	;TAKE MICROINSTRUCTION.
	DEC	R0		;CHANGE TO INDEX.
	ASL	R0		;CHANGE TO BYTE ADDRESS.
	BIC	#177400,R0	;CLEAR HIGH BYTE.
	TST	MESENB		;ASKED FOR SUBTITLES?
	BEQ	MIC1A		;NO.
	MOV	COMTAB(R0),MIC1	;PRINT MESSAGE
	CLR	GRQENB		;DISABLE DELAY OF GRAPHICS.
	JSR	R5,OUT		;PRINT MESSAGE.
MIC1:	.WORD	0,0
	JSR	R5,OUT
	.WORD	MICA,2
MIC1A:	MOV	MICTAB(R0),MIC2	;GRAPHICS TABLE
	TST	GRENB		;GRAPHIC LINES WANTED?
	BEQ	MIC2A
	INC	GRQENB		;ENABLE GRAPHICS DELAY.
	JSR	R5,OUT		;PRINT GRAPHICS.
MIC2:	.WORD	0,0
MIC2A:	CLR	GRQENB		;DISABLE DELAY.
	JSR	R5,@ACTTAB(R0)	;DO PROPER ACTION.
	JSR	R5,TIMSEQ	;PAUSE.
MIC3:	MOV	@MICPC,R1	;GET MICRO INSTR.
	BMI	MIC4		;SPECIAL JUMP.
	ADD	#2,MICPC	;GO TO NEXT MICRO WORD.
	BR	MICENT		;RETURN.
;
;		ROUTINE FOR CONDITIONAL MICRO JUMPS
;
MIC4:	MOV	MICPC,R0
	MOVB	1(R0),R1
	CMPB	#200,R1
	BEQ	MIC40		;UNCONDITIONAL JUMP
	CMPB	#201,R1		;COMPARE JUMPBYTE.
	BEQ	MIC41		;EXECUTE JUMP
	CMPB	#202,R1
	BEQ	MIC42		;GO TO SERVICE.
	CMPB	#203,R1
	BEQ	MIC43		;SKIP JUMP?
	CMPB	#204,R1
	BEQ	MIC44		;EXAMINE HALT.
	IOT			;PROGRAM ERROR.
;	WRONG MICROCODE IN MICROROM!!!!!!
;
;
;	JUMP ACCORDING TO EXECUTE TABLE.
;
MIC40:	ADD	#2,MICPC	;GO TO NEXT MICRO ADDRESS.
	MOV	@MICPC,MICPC	;LOAD JUMP ADDRESS.
	JMP	MICENT
MIC41:	MOV	IINDEX,R1	;PUT INSTRUCTION INDEX IN R1
	MOV	MEXTAB(R1),MICPC;JUMP TO INDEX
	JMP	MICENT		;TO ENTRY.
MIC42:	MOV	#MSERVC,MICPC	;GO TO SERVICE.
	JMP	MICENT		;BACK TO ENTRY.
MIC43:	MOV	CONDZE,R0	;SKIP CONDITION?
	BIT	#1,R0		;ZERO BIT SET?
	BNE	MIC43B		;YES.
	BIT	#2,R0		;MINUS BIT SET
	BNE	MIC43C		;YES.
;	IAL APPEARS TO BE POSITIVE
	CMP	#30,IINDEX	;SIP INSTRUCTION?
	BNE	MIC43A		;NO SKIP
MIC43D:	TST	MESENB		;ASKED FOR SUBTITLES?
	BEQ	MIC43E		;NO.
	JSR	R5,OUT		;YES !
	.WORD	IMES27,0
MIC43E:	ADD	#2,MICPC	;TAKE JUMP ADDRESS.
	MOV	@MICPC,MICPC	;JUMP BACK TO MICPC
	JMP	MICENT		;ENTRY
;
;
;
MIC43A:	TST	MESENB		;ASKED FOR SUBTITLES?
	BEQ	MIC43F		;NO
	JSR	R5,OUT		;NO!
	.WORD	IMES28,0
MIC43F:	ADD	#4,MICPC	;NO SKIP, JUMP OVER.
	JMP	MICENT		;NO ENTRY.
MIC43C:	CMP	#26,IINDEX	;SIM INSTRUCTION?
	BEQ	MIC43D
	BR	MIC43A
MIC43B:	CMP	#24,IINDEX	;SIZ INSTRUCTION?
	BEQ	MIC43D		;YES SKIP IS OK.
	CMP	#2,IINDEX	;INCREMENT SKIP IF ZERO.
	BEQ	MIC43D		;YES, SKIP!
	BR	MIC43A		;NOSKIP.
MIC44:	MOV	#MFETCH,MICPC	;GO TO START.
	JMP	MICENT
;
;	ACTION PROGRAMS
;/  /  /  /  /  /  /  /  /  /  /  /  /  /  /
;
;	CALL WITH JSR R5,ACTXX
;	THESE ROUTINES SO THE MICRO ACTIONS.
;	THEY ALSO SHOW THE CHANGED VALUES IN REGITER OR MEMORY.
;
;..........................................................
;
;	BRTOME
;BUFFER TO MEMORY.
;
ACT1:	RTS	R5		;NO ACTION.
;
;	BRTOAL
;BUFFER REGISTER TO ARITHMETIC UNIT.
;
ACT2:	MOV	IBR,IALB	;EXECUTE
	RTS	R5
;
;	ACTOAL
;ACCUMULATOR TO ARITHMETIC UNIT.
;
ACT3:	MOV	IAC,IALA	;EXECUTE
	RTS	R5
;
;	ALTOCA
;ARITHMETIC UNIT TO ACCUMULATOR
;
ACT4:	MOV	IAL,IAC		;EXECUTE
	JSR	R5,DISREG
	.WORD	IAC
	.POS	11.,5
	RTS	R5
;
;	ACTOBR
;
;ACCUMULATOR TO BUFFER REGISTER.
ACT5:	MOV	IAC,IBR		;EXECUTE.
	JSR	R5,DISREG
	.WORD	IBR
	.POS	4,8.
	RTS	R5
;
;	BRTOIR
;
;BUFFER REGISTER TO INSTRUCTION REGISTER.
ACT6:	MOV	IBR,IIR		;EXECUTE.
	JSR	R5,DISREG
	.WORD	IIR
	.POS	11.,33.
	RTS	R5
;
;	IRTODC
;INSTRUCTION REGISTER TO CONVERTOR.
;
ACT7:	MOV	IIR,R0
	BIC	#170000,R0	;INSTRUCTION IN R0
	CMP	R0,#7000	;7-INSTRUCTION?
	BHIS	ACT7S1
	BIC	#777,R0		;CLEAR ADDRESS.
ACT7S1:	MOV	#INSTAB,R2	;POINTER TO R2.
	CLR	R1		;INDEX TO 0
ACT7S9:	MOV	INATAB(R1),R3
	MOV	R3,ACT7S8	;TRANSFER ADDRESS.
	ADD	#2,R1		;INCREMENT INDEX
	TST	GRENB		;GRAPHICS ASKED?
	BEQ	ACT7S3
	JSR	R5,OUT
ACT7S8:	.WORD	0,8.		;FIXED LENGTH!!!!
ACT7S3:	CMP	R0,(R2)+	;KNOWN INSTRUCTION?
	BEQ	ACT7S2		;YES.
	CMP	R2,#ITABE	;END OF INSTRUCTION TABLE?
	BNE	ACT7S9		;NOT YES.
	MOV	#ERR1,R5
	RTS	R5		;JUMP TO ERROR ROUTINE.
;				INSTRUCTION NOT FOUND
ACT7S2:	TST	GRENB		;GRAPHICS ASKED?
	BNE	ACT7S4
	MOV	ACT7S8,ACT7S6	;TRANSFER CORRECT INSTRUCTION ADDRESS.
	JSR	R5,OUT
ACT7S6:	.WORD	0,8.
ACT7S4:	SUB	#INSTAB+2,R2	;MAKE INDEX ADDRESS OF R2.
	MOV	R2,IINDEX	;SAVE FOR MICRO EXECUTE JUMP.
	ADD	#INTB,R2	;COMMENT
	MOV	(R2),R2		;PICK UP THE ADDRESS.
	MOV	(R2)+,ACT7S5+2	;LENGTH.
	MOV	R2,ACT7S5	;ADDRESS.
	TST	MESENB		;ASKED FOR SUBTITLES?
	BNE	ACT7SA		;YES
	RTS	R5
ACT7SA:	JSR	R5,OUT		;COMMENT INSTRUCTION.
ACT7S5:	.WORD	0,0
	RTS	R5
;
;	IRTOPC
;INSTRUCTION REGISTER TO PROGRAM COUNTER.
;
ACT8:	MOV	IIR,R0
	BIC	#177000,R0	;ONLY THE ADDRESS
	MOV	R0,IPC
	JSR	R5,DISREG
	.WORD	IPC
	.POS	17.,52.
	RTS	R5
;
;	PCTOAR
;PROGRAM COUNTER TO ADDRESS REGISTER.
;
ACT9:	MOV	IPC,IAR		;EXECUTE.
	JSR	R5,DISREG
	.WORD	IAR
	.POS	6,52.
	RTS	R5
;
;	ARTOME
;ADDRESS REGISTER TO MEMORY.
;
ACT10:	JSR	R5,POINTM
	RTS	R5
;
;	IRTOAR
;INSTRUCTION REGISTER TO ADDRESS REGISTER.
;
ACT11:	MOV	IIR,R0
	BIC	#177000,R0	;ONLY THE ADDRESS.
	MOV	R0,IAR
	JSR	R5,DISREG
	.WORD	IAR
	.POS	6.,52.
	RTS	R5
;
;	PCPLON
;PROGRAM COUNTER PLUS ONE.
;
ACT12:	INC	IPC		;EXECUTE.
	JSR	R5,DISREG
	.WORD	IPC
	.POS	17.,52.
	RTS	R5
;
;	METOBR
;MEMORY TO BUFFER REGISTER.
;
ACT13:	MOV	IAR,R0		;TAKE WORD ADDRESS.
	ASL	R0		;MAKE BYTE ADDRESS.
	ADD	#IMEM,R0
	MOV	(R0),IBR	;EXECUTE.
	JSR	R5,DISREG
	.WORD	IBR
	.POS	4,8.
	RTS	R5
;
;	MMREAD
;READ MEMORY.
;
ACT14:	CMP	IAR,#MEMTOP	;HIGHER THAN 100.
	BHI	ACT141		;ILLEGAL ADDRESS.
	RTS	R5
ACT141:	MOV	#ERR2,R5	;ACORT TO ERROR ROUTINE.
	RTS	R5
;
;	MMWRIT
;WRITE MEMORY.
;
ACT15:	MOV	IAR,R0		;TAKE ADDRESS.
	CMP	R0,#MEMTOP	;TOP ADDRESS?
	BHI	ACT151		;ILLEGAL ADDRESS.
	ASL	R0		;MAKE BYTE ADDRESS.
	MOV	IBR,IMEM(R0)	;WRITE INTO MEMORY.
	ADD	#IMEM,R0
	MOV	R0,ACT15S	;TRANSFER REAL ADDRESS.
	MOV	IAR,R1
	SUB	IMEMVL,R1	;SUBSTRACT VIRTUAL BASE ADDRESS.
	CMPB	R1,#21.		;LOWEST POSITION?
	BHIS	ACT152
	ADD	#40,R1		;REAL POSITION.
	MOVB	R1,ACT15S+4	;SHOW CURSOR POSITION.
	JSR	R5,DISMEM
ACT15S:	.WORD	0
	.POS	1,72.
	JSR	R5,POINTM	;SHOW POINT.
ACT152:	RTS	R5
ACT151:	MOV	#ERR2,R5	;ABORT TO ERROR ROUTINE.
	RTS	R5
;
;	ACCUCL
;CLEAR ACCUMULATOR
;
ACT16:	CLR	IAC		;EXECUTE.
	JSR	R5,DISREG
	.WORD	IAC
	.POS	11.,5
	RTS	R5
;
;	ACTNO
;NO ACTION
;ALSO MEANS NO PAUSE FOR THE SCREEN.
;
ACTNO:	MOV	#MIC3,R5
	RTS	R5
;
;	SERVIC
;SERVICE STATE
;
ACT17:	MOVB	ISQMOD,R2	;NO WAIT?
	BEQ	ACT170
	CMPB	#1,R2		;AUTO STEP?
	BEQ	ACT171
	CMPB	#2,R2		;USER STEP?
	BEQ	ACT172
	IOT			;PROGRAM ERROR.
;. . . . . . . . . . . . . . . . . . . . . . .
ACT170:	TSTB	IOST		;KEYBOARD TOUCHED?
	BMI	ACT173
	RTS	R5		;NO FURTHER ACTION.
ACT171:	JSR	R5,WAIT		;WAIT NUMBER OF TICKS.
	.WORD	1,ISQMOD+2	;ACCORDING TO INSTRUCTION DELAY.
	TSTB	IOST		;KEYBOARD TOUCHED?
	BMI	ACT173
	RTS	R5		;AND BACK.
ACT172:	JMP	TIMS2		;COMMON ROUTINE WITH MICROPAUSE.
ACT173:	MOV	#ERR3,R5	;ABORT TO ERROR.
	RTS	R5
;
;	GOFETC
;GO TO FETCH STATE.
;
ACT18:	TST	MESENB		;NOTHING TO TAKE.
	BNE	ACT18A
	RTS	R5
ACT18A:	JSR	R5,OUT		;REMOVE INSTRUCTION.
ACT18S:	.WORD	MESA1,0
	RTS	R5
;
;	GOEXEC
;GO TO EXECUTE STATE.
;
ACT19:	RTS	R5		;NO ACTION
;
;	EXEALU
;EXECUTE THE FUNCTION IN THE ARITHMETIC UNIT
;
ACT20:	MOV	IINDEX,R0	;GET OLD INDEX
	JMP	@EXALTB(R0)	;JUMP TO PROPER ROUTINE.
ACT209:				;ADD I
ACT201:	MOV	IALA,R0		;ADD
	ADD	IALB,R0
	BIC	#170000,R0	;12-BIT
	MOV	R0,IAL
	JSR	R5,CONSET	;SET CONDITION REGISTER.
	RTS	R5
ACT202:	MOV	IALB,IAL	;ISZ
	CLR	CONDZE		;PRESET CONDITION
	INC	IAL
	BIC	#170000,IAL	;12-BIT
	JSR	R5,CONSET	;SET CONDITION REGISTER.
	RTS	R5
ACT210:				;STR I
ACT211:				;SIZ
ACT212:				;SIM
ACT213:				;SIP
ACT203:
ACT204:	RTS	R5		;JMP
ACT205:	MOV	IALA,IAL	;IAC
	INC	IAL
	BIC	#170000,IAL	;12-BIT
	JSR	R5,CONSET	;SET CONDITION REGISTER.
	RTS	R5
ACT206:	MOV	IALA,R0		;CMA
	COM	R0
	BIC	#170000,R0	;12-BIT
	MOV	R0,IAL
	JSR	R5,CONSET	;SET CONDITION REGISTER.
	RTS	R5
ACT207:				;CLA
ACT208:	RTS	R5		;HLT
;
;	ALTOBR
;ARITHMETIC UNIT OUTPUT TO BUFFER REGISTER.
;
ACT37:	MOV	IAL,IBR		;EXECUTE.
	JSR	R5,DISREG	;DISPLAY REGISTER
	.WORD	IBR
	.POS	4,8.
	RTS	R5
;
;	GOHALT
;GO TO THE HALT CONDITION.
;
ACT39:	JSR	R5,OUT		;GO ON OR TO CONSOLE?
ACT391:	.WORD	IMES15,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'G	;GO ON?
	BEQ	ACT392
	CMPB	GENBUF,#'C	;TO CONSOLE?
	BEQ	ACT393
	BR	ACT39
ACT392:	JSR	R5,OUT		;SET FOR RUN.
	.WORD	GENM2,8.
	JSR	R5,OUT		;CLEAR SUBTITLES.
	.WORD	MES1+2,6
	JSR	R5,OUT		;CLEAR ILLEGAL INSTRUCTION.
	.WORD	MESA1,0
	RTS	R5
ACT393:	MOV	#RST1A,R5
	RTS	R5		;ABORT TO CONSOLE.
;
;	BRTOAR
;
ACT40:	MOV	IBR,IAR		;EXECUTE.
	JSR	R5,DISREG	;DISPLAY IAR
	.WORD	IAR
	.POS	6,52.
	RTS R5
;
;	MUSKIP
;
ACT42:	RTS	R5		;NO ACTION.

;	E R R O R   R O U T I N E S
;, , , , , , , , , , , , , , , , , , , , , , , , ,
;
;ERROR 1	ILLEGAL INSTRUCTION.
;
ERR1:	JSR	R5,OUT
ERR11:	.WORD	IMES16,0
ERR12:	MOV	#MA8A,MICPC	;GO TO HALT.
	JSR	R5,WAIT
	.WORD	0,100.
	JMP	MICENT		;BACK.
;
;ERROR 2	ILLEGAL MEMORY ADDRESS.
;
ERR2:	JSR	R5,OUT		;PRINT ERROR MESSAGE.
ERR21:	.WORD	IMES17,0
	JMP	ERR12
;
;ERROR 3	SOMEBODY HAS PUSHED SOMETHING DURING THE RUN
;
ERR3:	JSR	R5,OUT		;ASK IF MISTAKE
ERR31:	.WORD	IMES11,0
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#'Y	;YES.
	BEQ	ERR32
	CMPB	GENBUF,#'N	;NO.
	BEQ	ERR33
	BR	ERR3
ERR32:	JSR	R5,OUT		;JUST GO ON.
	.WORD	GENM2,8.
	JSR	R5,OUT		;SET RUN AND CLEAR SUBTITLE.
	.WORD	MES1+2,6
	JMP	MIC3		;GO ON.
ERR33:	JMP	RST1A
;
;	SUBROUTINE	TIME/PAUSE SEQUENCER.
;
;	CALL WITH JSR R5,TIMSEQ FROM THE MICROCODE-INTERPRETER.
;
TIMSEQ:	MOVB	SEQMOD,R2	;NOWAIT?
	BEQ	TIMS0
	CMPB	#1,R2		;AUTO STEP?
	BEQ	TIMS1
	CMPB	#2,R2		;USER STEP?
	BEQ	TIMS2
	IOT			;PROGRAM ERROR.!!!
TIMS0:	RTS	R5		;NOWAIT.
TIMS1:	JSR	R5,WAIT		;WAIT NUMBER OF TICKS.
	.WORD	1,SEQMOD+2	;ASKED BETWEEN MICRO STEPS.
	RTS	R5
TIMS2:	JSR	R5,OUT		;SET ON WAIT
	.WORD	GENM1,8.
	JSR	R5,IN
	.WORD	1
	CMPB	GENBUF,#SPACE
	BNE	TIMS3		;SOMETHING ELSE IS THE MATTER
	JSR	R5,OUT
	.WORD	GENM2,8.
	RTS	R5
TIMS3:	MOV	#ERR3,R5	;ABORT TO ERROR ROUTINE
	RTS	R5
;
;	SUBROUTINE IN
;	ROUTINE TO READ A NUMBER OF CHARACTERS FROM THE KEYBOARD AND
;	PUT THEM INTO GENBUF.
;	FIRST ARGUMENT IS THE NUMBER OF CHARACTERS.
;	CALL WITH JSR R5,IN.
IN:	MOV	R0,-(SP)
	MOV	R1,-(SP)	;SAVE
	MOV	R2,-(SP)
	MOV	(R5)+,R2	;NUMBER OF CHAR.
	MOV	#GENBUF,R1
	QIOW$S	#IO.RVB,#5,#5,,#IOSTAT,,<R1,R2>
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0	;RESTORE
	RTS	R5
;
;	SUBROUTINE OUT
;
;	ROUTINE TO SEND MESSAGES TO THE SCREEN.
;	CALL WITH JSR R5,OUT.
;	FIRST ARGUMENT IS ADDRESS OF DATA BLOCK.
;	SECOND ARGUMENT IS THE LENGTH OF THE DATABLOCK IN BYTES.
;	IF LENGTH IS ZERO, THEN IT IS THE FIRST WORD OF THE DATA BLOCK.
;
OUTAA:	.BYTE	CR,0
OUTAB:	.WORD	0,0
OUT:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	MOV	(R5)+,R0	;ADDRESS
	MOV	(R5)+,R1	;LENGTH
	BNE	OUT1A
	MOV	(R0)+,R1	;LENGTH IS IN THE BLOCK.
OUT1A:	MOV	#BOUT,R2	;AUXILIARY BUFFER
	MOV	R1,R3		;COUNT LENGTH.
OUT1:	CMPB	(R0),#ESC	;IS IT AN ESC?
	BEQ	OUT2
OUT3:	TST	GRQENB		;DELAY ENABLED?
	BEQ	OUT3A
	TST	GRQMOD		;DELAY MODE ASKED FOR?
	BEQ	OUT3A
	MOVB	(R0)+,R2	;GET BYTE
	MOV	R2,OUTAB	;PUT INTO MEMORY
	CMP	R2,#040		;PRINTABLE CHARACTER?
	BLOS	OUT3B
	JSR	R5,WAIT
	.WORD	1,GRQMOD+2	;ADDRESS OF NUMBER OF DELAYED TICKS.
OUT3B:	QIOW$S	#IO.WVB,#5,#5,,,,<#OUTAB,#1>
	DEC	R3		;DECREMENT COUNTER
	BNE	OUT1
	BR	OUT5
OUT3A:	MOVB	(R0)+,(R2)+	;MOVE BYTO FROM BUF TO BUF
	DEC	R3
	BNE	OUT1
	QIOW$S	#IO.WVB,#5,#5,,,,<#BOUT,R1>
OUT5:	MOV	(SP)+,R4
	MOV	(SP)+,R3
	MOV	(SP)+,R2	;RESTORE
	MOV	(SP)+,R1	;RESTORE REGISTERS.
	MOV	(SP)+,R0
	RTS	R5
	BR	OUT3
OUT2:	CMPB	1(R0),#131	;NEXT IS Y?
	BEQ	OUT4
	CMPB	1(R0),#'J	;CLEAN SCREEN?
	BEQ	OUT4
	CMPB	1(R0),#'H	;HOME?
	BNE	OUT3
OUT4:	TST	GRQENB
	BEQ	OUT4A
	TST	GRQMOD
	BEQ	OUT4A
	QIOW$S	#IO.WVB,#5,#5,,,,<#OUTAA,#1>
	BR	OUT3		;AND BACK
OUT4A:	MOVB	#CR,(R2)+	;PUSH CR
	INC	R1		;INCREMENT LENGTH
	BR	OUT3		;ADD ESC AND GO TO NEXT.
;
;	SUBROUTINE COCBIN
;
COCBIN:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	(R5),R0		;TAKE ADDRESS
	MOV	2(R5),R1	;TAKE LENGTH
	INC	COCBA
COCB2:	CMPB	(R0),#60
	BLO	COCB1
	CMPB	(R0)+,#67
	BHI	COCB1
	DEC	R1		;LAST CHECKED?
	BNE	COCB2
	CLR	COCBA		;NO FAULTS.
	CLR	R2		;CLEAN RESULT.
	MOV	(R5),R0
	MOVB	(R0)+,R1	;FIRST OC
	BIC	#770,R1		;CONVERT FIRST BYTE.
	MOV	2(R5),R3	;GET NUMBER OF BYTES.
	DEC	R3		;I ALREADY HAVE ONE.
	BEQ	COCB1		;READY.
	MOVB	(R0)+,R2	;GET NEXT
	BIC	#770,R2
	JSR	R5,SHFLFT	;SHIFT LEFT
	.WORD	3		;3 TIMES
	BIS	R2,R1		;ADD
	DEC	R3		;DECREMENT BYTE COUNT.	
	BEQ	COCB1
	MOVB	(R0)+,R2	;GET 3RD CHAR.
	BIC	#770,R2
	JSR	R5,SHFLFT
	.WORD	3
	BIS	R2,R1
	DEC	R3
	BEQ	COCB1		;LAST?
	MOVB	(R0)+,R2	;GET 4TH CHAR,
	BIC	#770,R2
	JSR	R5,SHFLFT
	.WORD	3
	BIS	R2,R1		;ADD LAST.
COCB1:	MOV	R1,4(R5)	;PUT RESULT.
	ADD	#6,R5
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	R5		;RETURN.
COCBA:	.WORD 0			;1=WRONG, 0=RIGHT NUMBER OF OCTALS.
;
;	SUBROUTINE WAIT
;
;	ROUTINE TO WAIT A NUMBER OF TICKS.
;	FIRST ARGUMENT 0, THEN THE SECOND ARGUMENT IS A CONSTANT WHICH
;	THE NUMBER OF TICKS.
;	FIRST ARGUMENT 1, THEN THE SECOND ARGUMENT IS AN ADDRESS WHICH
;	CONTAINS THE NUMBER OF TICKS OF 20 MSEC TO WAIT.
;
WAIT:	MOV	R0,-(SP)	;SAVE
	MOV	(R5)+,R0	;GET FIRST ARGUMENT
	BNE	WAIT1
	MOV	(R5)+,R0	;GET CONSTANT
	MOV	R0,TIME+2
WAIT2:	MRKT$S	#1,TIME+2,#1
	WTSE$S	#1		;WAIT FOR FLAG
	MOV	(SP)+,R0	;RESTORE.
	RTS	R5
WAIT1:	MOV	@(R5)+,R0	;GET CONSTANT INDIRECTLY.
	MOV	R0,TIME+2
	BR	WAIT2
;
;	SUBROUTINE CBINOC
;	ROUTINE TO CONVERT FROM BINARY TO OCTAL.
;	FIRST ARGUMENT IS THE ADDRESS OF THE INTERNAL REGISTER.
;	SECOND TWO WORDS CONTAIN THE FOUR OCTAL BYTES.
;	CALL WITH JSR R5,CBINOC
;
CBINOC:	MOV	R0,-(SP)	;SAVE
	MOV	R1,-(SP)
	MOV	(R5)+,R0	;GET ADDRESS.
	ADD	#3,R5		;POINT TO LSB BYTE.
	MOV	(R0),R1		;GET BINARY NUMBER.
	BIC	#177770,R1	
	JSR	R4,SHIFT	;PUT 1ST OC IN PLACE.
	.WORD	0		;NUMBER OF SHIFTS.
	MOV	(R0),R1		;GET BINARY NUMBER.
	BIC	#177707,R1	
	JSR	R4,SHIFT	;REPEAT FOR 2ND OC.
	.WORD	3		;NUMBER OF SHIFTS.
	MOV	(R0),R1		;GET BINARY NUMBER.
	BIC	#177077,R1	
	JSR	R4,SHIFT	;REPEAT FOR 3RD OC.
	.WORD	6		;NUMBER OF SHIFTS.
	MOV	(R0),R1		;GET BINARY NUMBER.
	BIC	#170777,R1	
	JSR	R4,SHIFT	;REPEAT FOR 4TH OC.
	.WORD	9.		;NUMBER OF SHIFTS.
	ADD	#5,R5
	MOV	(SP)+,R1	;RESTORE
	MOV	(SP)+,R0
	RTS	R5
;
;	SUBROUTINE SHIFT
;
;	SHIFTS THE VALUE IN R1 A NUMBER OF TIMES TO THE RIGHT.
;	FIRST ARGUMENT IS THE NUMBER OF SHIFTS.
;	THEN OC IS MADE BY ADDING 030, AND STORED IN MEMORY,
;	POINTED TO BY R5. R5 IS DECREMENTED ONE.
;	CALL WITH JSR R4,SHIFT. (NOT R5!!!!).
;
SHIFT:	MOV	R0,-(SP)	;SAVE
	MOV	(R4)+,R0	;NUMBER OF TIMES.
SHIFT1:	TST	R0
	BEQ	SHIFT0		;READY?
	ASR	R1
	DEC	R0
	BR	SHIFT1
SHIFT0:	BIS	#60,R1		;MAKE OCTAL
	MOVB	R1,(R5)		;PUT IN MEMORY.
	DEC	R5		;DECREMENT POINTER.
	MOV	(SP)+,R0	;RESTORE.
	RTS	R4
;
;	SUBROUTINE SHFLFT
;
;	ROUTINE TO SHIFT A VALUE IN R1 TO THE LEFT.
;	FIRST ARGUMENT IS THE NUMBER OF SHIFTS.
;	CALL WITH JSR R5,SHFLFT
;
SHFLFT:	MOV	R0,-(SP)	;SAVE
	MOV	(R5)+,R0	;NUMBER OF TIMES.
SHL2:	TST	R0
	BEQ	SHL1
	ASL	R1
	DEC	R0
	BR	SHL2
SHL1:	MOV	(SP)+,R0	;RESTORE.
	RTS	R5
;
;	SUBROUTINE DISREG.
;
;	ROUTINE TO GIVE A BINARY OR OCTAL DISPLAY OF THE CONTENTS
;	OF A REGISTER ON THE SCREEN.
;	FIRST ARGUMENT IS THE ADDRESS OF THE INTERNAL REGISTER.
;	AFTER THAT FOUR BYTES MUST FOLLOW.
;	CALL JSR R5,DISREG
;
DISREG:	MOV	R0,-(SP)	;SAVE
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	TST	OCBINR		;OCTAL OR BINARY?
	BNE	DISR4		;BINARY
	MOV	(R5)+,DISR2	;ADDRESS
	JSR	R5,CBINOC	;CONVERT BINARY TO OCTAL
DISR2:	.WORD	0		;ADDRESS OF REGISTER
	.BLKB	4		;RESULT
	MOV	#SPACE,R0
	MOV	#GENBUF,R1
	MOV	#DISR2+2,R2	;OCTAL RESULT.
	MOV	(R5)+,(R1)+	;TRANSFER POSITIONING.
	MOV	(R5)+,(R1)+	;4 BYTES
	MOVB	R0,(R1)+	;SPACE
	MOVB	(R2)+,(R1)+	;OCTAL
	MOVB	R0,(R1)+	;SPACE
	MOVB	R0,(R1)+	;SPACE
	MOVB	(R2)+,(R1)+	;OCTAL
	MOVB	R0,(R1)+	;SPACE
	MOVB	R0,(R1)+	;SPACE
	MOVB	(R2)+,(R1)+	;OCTAL
	MOVB	R0,(R1)+	;SPACE
	MOVB	R0,(R1)+	;SPACE
	MOVB	(R2)+,(R1)+	;OCTAL
	MOVB	R0,(R1)+	;SPACE
	JSR	R5,OUT
DISR3:	.WORD	GENBUF,16.
	BR	DISR7
DISR4:	MOV	(R5)+,DISR5	;BINARY TI OC-BINARY.
	MOV	(R5)+,DISR5+2	;TRANSFER POSITIONING,
	MOV	(R5)+,DISR5+4
	JSR	R5,CBINBI
DISR5:	.WORD	0		;ADDRESS OF THE REGISTER
	.BLKB	4		;POSITIONING DATA.
	.BLKB	12.		;12 BIN CHARACTERS.
	JSR	R5,OUT		;PRINT
DISR6:	.WORD	DISR5+2,16.
DISR7:	MOV	(SP)+,R2	;RESTORE
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	R5
;
;	SUBROUTINE DISMEM
;
;	CALL WITH JSR R5,DISMEM
;	MAKES AN OCTAL DISPLAY OF A MEMORY LOCATION.
;	FIRST ARGUMENT IS THE REAL ADDRESS OF THE MEMORY LOCATION.
;	AFTER THAT 4 BYTES FOLLOW FOR CURSOR POSITIONING.
;	IN IAR IS THE ADDRESS OF WHAT IS DISPLAYED.
;
DISMEM:	MOV	R0,-(SP)	;SAVE
	MOV	R1,-(SP)
	MOV	(R5)+,DISM2
	JSR	R5,CBINOC
DISM1:	.WORD	IAR
	.BLKB	4		;OCTAL BYTES
	MOV	#GENBUF,R0
	MOV	(R5)+,(R0)+	;POSITION IN GENBUF
	MOV	(R5)+,(R0)+
	MOV	DISM1+2,(R0)+	;ADD OCTAL .
	MOV	DISM1+4,(R0)+
	MOVB	#SPACE,(R0)+
	JSR	R5,CBINOC	;OCTAL MEMORY LOCATION.
DISM2:	.WORD	0
	.BLKB	4		;RESULT : 4 OC BYTES.
	MOV	#DISM2+2,R1
	MOVB	(R1)+,(R0)+
	MOVB	(R1)+,(R0)+
	MOVB	(R1)+,(R0)+
	MOVB	(R1)+,(R0)+
	JSR	R5,OUT
DISM3:	.WORD	GENBUF,13.
	MOV	(SP)+,R1	;RESTORE
	MOV	(SP)+,R0
	RTS	R5
;
;	SUBROUTINE DISCON
;
;	SUBROUTINE TO DISPLAY THE CONTENTS OF THE CONDITION REGISTER.
;	CAL WITH JSR R5,DISCON.
;	CONDZE IS THE CONDITION REGISTER.
;	00 : POSITIVE, 01 : ZERO, 10 : MINUS.
;
DISCON:	BIT	#1,CONDZE	;ZERO?
	BNE	DISCO1		;YES
	BIT	#2,CONDZE	;MINUS
	BNE	DISCO2		;YES, MINUS
	JSR	R5,OUT
	.WORD	IMES25,0	;POSITIVE
	RTS	R5
DISCO1:	JSR	R5,OUT
	.WORD	IMES24,0	;ZERO
	RTS	R5
DISCO2:	JSR	R5,OUT
	.WORD	IMES26,0	;MINUS
	RTS	R5
;
;	SUBROUTINE CONSET
;
;	THIS SUBROUTINE SETS THE CONDITION REGISTER REGARDLESS THE
;	OUTPUT OF THE ARITHMETIC UNIT ial.
;
;	BIT 0 IS THE ZERO BIT, BIT 1 IS THE MINUS BOT.
;	BIT 0 AND 1 BECOME 00 IF THE RESULT APPEARS TO BE POSITIVE.
;	CALL WITH JSR R5, CONSET.
;
CONSET:	MOV	R0,-(SP)	;SAVE
	MOV	IAL,R0		;PLACE OUTPUT ALU IN R0 AND TEST.
	BEQ	CONSE1		;ZERO RESULT.
	BIT	#4000,R0	;SIGN BIT SET?
	BNE	CONSE2		;YES, SO MINUS BIT 1
	CLR	CONDZE		;POSITIVE RESULT
CONSE3:	MOV	(SP)+,R0	;RESTORE
	JSR	R5,DISCON	;DISPLAY ON SCREEN
	RTS	R5
CONSE1:	MOV	#1,CONDZE	;SET ZERO BIT.
	BR	CONSE3
CONSE2:	MOV	#2,CONDZE	;SET MINUS BIT
	BR	CONSE3
;
;	SUBROUTINE POINTM
;
;	SHOW AN ARROW AT THE PLACE WHERE THE MEMORY IS BEING ACCESSED.
;	CALL WITH JSR R5,POINTM.
;	ADDRESS IS GIVER BY IAR.
;
POINTM:	MOV	R0,-(SP)	;SAVE
	MOVB	#SPACE,POIN1+4	;REMOVE PREVIOUS ARROW
	JSR	R5,OUT
	.WORD	POIN1,5
	MOV	IAR,R0
	SUB	IMEMVL,R0	;BASE VISUAL ADDRESS OFF.
	CMP	R0,#21.		;NOT VISIBLE?
	BHIS	POIN2
	ADD	#40,R0		;ADD POSITION.
	MOVB	R0,POIN1+2
	MOVB	#'>,POIN1+4	;ARROW IN BUFFER
	JSR	R5,OUT		;PRINT >
	.WORD	POIN1
	.WORD	5		;LENGTH.
POIN2:	MOV	(SP)+,R0	;RESTORE
	RTS	R5
POIN1:	.POS	1,71.
	.BYTE	'>
	.EVEN
;
;	SUBROUTINE CBINBI
;
;	ROUTINE TO CONVERT A 12 BIT BINARY NUMBER TO 12 OCTAL BYTES.
;	CALL WITH JSR R5,CBINBI.
;	FIRST ARGUMENT IS THE ADDRESS OF THE INTERNAL REGISTER.
;	THE FOUR NEXT BYTES ARE NOT TO BE USED, THEY ARE FOR POSITIONING,
;	THE NEXT 12 BYTES ARE FOR THE RESULT.
;
CBINBI:	MOV	R0,-(SP)	;SAVE
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	#12.,R0
	MOV	@(R5),R1	;VALUE IN R1
	ADD	#18.,R5		;R5 UNDER LOWEST BOUNDARY
CBINB1:	MOV	R1,R2
	BIC	#177776,R2	;KEEP BIT 0
	BIS	#60,R2		;MAKE OCTAL ASCII
	MOVB	R2,-(R5)	;STORE
	ASR	R1		;SHIFT
	DEC	R0		;DECREMENT COUNTER.
	BNE	CBINB1		;BACK.
	ADD	#12.,R5		;R5 TO RETURN ADDRESS.
	MOV	(SP)+,R2	;RESTORE
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	R5
;
;	SUBROUTINE SHOMEM
;
;	SHOW THE CONTENTS OF THE ENTIRE MEMORY IN CONSOLE MODE.
;	CALL WITH JSR R5,SHOMEM.
;	FIRST ARGUMENT :
;	1 = CLEAN SCREEN, 0 = DO NOT BOTHER, -1 = DISPLAY A WORD.
;	-2 = REMOVE OLD POINTS INDICATED BY OUDVL AND OUDVH AND SHOW
;	NEW POINTS.
;
SHOMEM:	MOV	R0,-(SP)	;SAVE
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	IAR,-(SP)	;SAVE IAR
	MOV	IMES18,SHOM1+2	;LENGTH NORMAL+CLEAN
	MOV	#IMES18+2,SHOM1	;ADDRESS+CLEAN
	MOV	(R5)+,R0	;IS THAT WANTED?
	BEQ	SHOM2
	BMI	SHOM3		;ONLY ONE, SO NO TITLES.
SHOM1A:	JSR	R5,OUT
SHOM1:	.WORD	0,0
SHOM3:	MOV	#3,R0		;POSITION Y
	CLR	IAR		;ADDRESS ON 0
	MOV	#1,R1		;POSITION X
SHOM4:	MOV	IAR,R2
	ASL	R2		;BYTE ADDRESS
	ADD	#IMEM,R2
	MOV	R2,SHOM5	;REAL MEMORY ADDRESS OVER.
	MOV	R1,SHOM1	;CALCULATE CORRECT POSITION
	ADD	#40,SHOM1
	MOVB	SHOM1,SHOM5+5	;TRANSFER X
	MOV	R0,SHOM1
	ADD	#37,SHOM1
	MOVB	SHOM1,SHOM5+4	;TRANFER Y.
	CMP	-2(R5),#-1.	;ONE WORD?
	BNE	SHOM4A		;NO
	CMP	(SP),IAR	;IAR EQUAL?
	BNE	SHOM5A
SHOM4A:	CMP	-2(R5),#-2.	;NOT ONLY AT POINTS DISPLAY
	BEQ	SHOM5A
	JSR	R5,DISMEM	;DISPLAY MEMORY
SHOM5:	.WORD	0
	.POS	1,1
SHOM5A:	CMP	IAR,IMEMVL	;BELOW LOWER BOUNDARY.
	BLO	SHOM6A		;NO STAR
	CMP	IAR,IMEMVH	;ABOVE HIGH BOUNDARY?
	BHI	SHOM6A
	MOV	SHOM5+4,SHOMA+2	;TRANFER X AND Y.
	CMP	-2(R5),#-1.	;ONE WORD?
	BNE	SHOM5B
	CMP	(SP),IAR	;MATCH OLD AND RUNNING IAR?
	BNE	SHOM6
SHOM5B:	JSR	R5,OUT
	.WORD	SHOMA,5		;SHOW VISUAL MEMORY.
SHOM6:	INC	IAR
	CMP	#MEMTOP+1,IAR	;LAST?
	BEQ	SHOM7
	INC	R0		;INCREMENT Y
	CMP	R0,#18.		;LOWEST Y POS?
	BNE	SHOM4		;BACK AND REPEAT.
	MOV	#3,R0		;Y UP
	ADD	#11.,R1		;X 11 FURTHER TO THE RIGHT.
	BR	SHOM4
SHOM6A:	CMP	IAR,OUDVL	;COMPARE OLD BOUNDARIES.
	BLO	SHOM6
	CMP	IAR,OUDVH
	BHI	SHOM6
	CMP	-2(R5),#-2.	;ONLY POINTS?
	BNE	SHOM6		;NO
	MOV	SHOM5+4,SHOMB+2	;TRANSFER X AND Y.
	JSR	R5,OUT		;CHANGE STAR IN 0
	.WORD	SHOMB,5
	BR	SHOM6
SHOM2:	SUB	#4,SHOM1+2	;DECREMENT LENGTH NO CLEAR.
	ADD	#4,SHOM1	;INCREMENT ADDRESS.
	BR	SHOM1A
SHOM7:	MOV	(SP)+,IAR	;RESTORE
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	R5
SHOMA:	.POS	1,1
	.BYTE	'*
	.EVEN
SHOMB:	.POS	1,1
	.BYTE	'0
	.EVEN

; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
;
;	MESSAGES
;	MESSAGES GIVEN DURING RUN MODE FOR ONE MICRO OPERATION.
;
	.NLIST	BEX
	.ENABL	LC
MES1:	.WORD	MES2-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<BRTOME>/
	.ASCII	/ buffer register to memory/
	.EVEN
;
MES2:	.WORD	MES3-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<BRTOAL>/
	.ASCII	/ buffer register to arithmetic unit/
	.EVEN
;
MES3:	.WORD	MES4-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<ACTOAL>/
	.ASCII	/ accumulator to arithmetic unit/
	.EVEN
;
MES4:	.WORD	MES5-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<ALTOAC>/
	.ASCII	/ arithmetic unit to accumulator/
	.EVEN
;
MES5:	.WORD	MES6-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<ACTOBR>/
	.ASCII	/ accumulator to buffer register/
	.EVEN
;
MES6:	.WORD	MES7-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<BRTOIR>/
	.ASCII	/ buffer register to instruction register/
	.EVEN
;
MES7:	.WORD	MES8-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<IRTODC>/
	.ASCII	/ instruction to decoder and control unit/
	.EVEN
;
MES8:	.WORD	MES9-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<IRTOPC>/
	.ASCII	/ address of instruction to the program counter/
	.EVEN
;
MES9:	.WORD	MES10-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<PCTOAR>/
	.ASCII	/ program counter to address register/
	.EVEN
;
MES10:	.WORD	MES11-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<ARTOME>/
	.ASCII	/ address register to memory/
	.EVEN
;
MES11:	.WORD	MES12-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<IRTOAR>/
	.ASCII	/ address of instruction register to address register/
	.EVEN
;
MES12:	.WORD	MES13-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<PCPLON>/
	.ASCII	/ increment program counter with one/
	.EVEN
;
MES13:	.WORD	MES14-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<METOBR>/
	.ASCII	/ memory output to buffer register/
	.EVEN
;
MES14:	.WORD	MES15-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<MMREAD>/
	.ASCII	/ read from memory/
	.EVEN
;
MES15:	.WORD	MES16-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<MMWRIT>/
	.ASCII	/ write to memory/
	.EVEN
;
MES16:	.WORD	MES17-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<ACCULC>/
	.ASCII	/ clear accumulator and make it zero/
	.EVEN
;
MES17:	.WORD	MES18-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<SERVIC>/
	.ASCII	/ go to the service state/
	.EVEN
;
MES18:	.WORD	MES19-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<GOFETC>/
	.ASCII	/ go to the fetch state, get next instruction/
	.EVEN
;
MES19:	.WORD	MES20-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<GOEXEC>/
	.ASCII	/ go to the execute state, execute instruction/
	.EVEN
;
MES20:	.WORD	MESCL-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<EXEALU>/
	.ASCII	/ execute instruction function in arithmetic unit/
	.EVEN
;
MESCL:	.WORD	MES37-.-2
	.POS	24.,13.
	.CLIN
	.EVEN
;
MES37:	.WORD	MES39-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<ALTOBR>/
	.ASCII	/ result arithmetic unit goes to buffer register/
	.EVEN
;
MES39:	.WORD	MES40-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<GOHALT>/
	.ASCII	/ stop ! !/
	.EVEN
;
MES40:	.WORD	MES42-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<BRTOAR>/
	.ASCII	/ address of the buffer register to address register/
	.EVEN
;
MES42:	.WORD	MES43-.-2
	.POS	24.,13.
	.CLIN
	.ASCII	/<MUSKIP>/
	.ASCII	/ compare instruction condition with alu output /
	.EVEN
;
MES43:
MESA1:	.WORD	MESA2-.-2
	.POS	23.,13.
	.STRING	54.,SPACE
	.POS	17.,41.
	.STRING	5.,SPACE
	.EVEN
;
MESA2:
;
; ; ; ; ; ;; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
;
;	G R A P H I C   D A T A   A R E A
;
; ; ; ; ; ;; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
;
SETRAS:	.WORD	LAB1-.-2
	.BYTE	LF,CR,ESC,'H,ESC,'J	;ERASE SCREEN
	.POS	3,6			;DRAW BUFFER REGISTER.
	.REG	'*,'*,'*
	.POS	2,4
	.ASCII	/  BUF.REG./
	.POS	10.,3
	.REG	'*,'*,'*		;DRAW ACCUMULATOR.
	.POS	9.,4
	.ASCII	/ACCU./
	.POS	5,50.			;DRAW AR
	.REG	'*,'*,'*
	.POS	4,46.
	.ASCII	/  ADDRESS REG./
	.POS	16.,50.			;DRAW PC
	.REG	'*,'*,'*
	.POS	15.,48.
	.ASCII	/  PROG.COUNT./
	.POS	10.,31.			;DRAW IR
	.REG	'*,'*,'*
	.POS	9.,30.
	.ASCII	/ INSTR.REG./
	.POS	16.,31.			;DRAW DECODER
	.REG	'-,'[,']
	.POS	17.,33.
	.ASCII	/DECODER:/
	.POS	19.,38.			;DRAW CONTROL
	.BYTE	'!
	.POS	20.,31.
	.REG	'=,'#,'#
	.POS	21.,33.
	.ASCII	/CONTROL:/
	.POS	24.,1			;WRITE COMMENT
	.ASCII	/Micro-step:/
	.BYTE	ESC,'A
	.POS	23.,1
	.ASCII	/Instruction: /
	.POS	1,70.			;MEMORY SEPARATION
	.DOWN	22.,'.
	.POS	22.,72.			;MEMORY BANK
	.ASCII	/MEMORY/
	.POS	23.,73.
	.ASCII	/BANK/
	.POS	16.,13.			;DRAW ALU
	.STRING	12.,'*
	.POS	20.,13.
	.STRING	12.,'*
	.POS	17.,12.
	.BYTE	'*,LF,BS,'*,LF,BS,'*
	.POS	17.,25.
	.DOWN	3,'*
	.POS	15.,11.
	.ASCII	/ALU/
	.POS	18.,14.
	.ASCII	/ARITHMETIC/
	.POS	19.,17.
	.ASCII	/UNIT/
	.BYTE	0			;END INITIAL SET-UP
LAB1:
	.EVEN
;
;	BRTOME
;
GRAP1:	.WORD	GRAP21-.-2
	.POS	2.,13.
	.BYTE	'^
	.POS	1,13.
	.STRING	57.,'>
	.POS	2,33.
	.ASCII	/DATA TO MEMORY/
	.EVEN
;
GRAP21:	.WORD	GRAP2-.-2
	.POS	2,13.
	.BYTE	SPACE
	.POS	1,13.
	.STRING	57.,SPACE
	.POS	2,33.
	.STRING	16.,SPACE
	.EVEN
;
;	BRTOAL
;
GRAP2:	.WORD	GRAP22-.-2
	.POS	6,13.
	.BYTE	'!,LF,BS
	.STRING	9.,'-
	.DOWN	9.,'!
	.EVEN
;
;	BRCLAL
;
GRAP22:	.WORD	GRAP3-.-2
	.POS	6,13.
	.BYTE	SPACE,LF,BS
	.STRING	9.,SPACE
	.DOWN	9.,SPACE
	.EVEN
;
;	ACTOAL
;
GRAP3:	.WORD	GRAP23-.-2
	.POS	13.,10.
	.BYTE	'!,LF,BS
	.STRING	5.,'-
	.DOWN	2,'!
	.EVEN
;
;	ACCLAL
;
GRAP23:	.WORD	GRAP4-.-2
	.POS	13.,10.
	.BYTE	SPACE,LF,BS
	.STRING	5.,SPACE
	.DOWN	2.,SPACE
	.EVEN
;
;	ALTOAC
;
GRAP4:	.WORD	GRAP24-.-2
	.POS	21.,18.
	.BYTE	'!,LF,BS
	.LEF	18.,'-
	.UP	14.,'!
	.STRING	10.,'-
	.BYTE	BS,LF,'!
	.EVEN
;
;	ALCLAC
;
GRAP24:	.WORD	GRAP5-.-2
	.POS	21.,18.
	.BYTE	SPACE,LF,BS
	.LEF	18.,SPACE
	.UP	14.,SPACE
	.STRING	10.,SPACE
	.BYTE	BS,LF,SPACE
	.EVEN
;
;	ACTOBR
;
GRAP5:	.WORD	GRAP25-.-2
	.POS	9.,12.
	.UP	4.,'!
	.EVEN
;
;	ACCLBR
;
GRAP25:	.WORD	GRAP6-.-2
	.POS	9.,12.
	.UP	4.,SPACE
	.EVEN
;
;	BRTOIR
;
GRAP6:	.WORD	GRAP26-.-2
	.POS	6.,13.
	.BYTE	'!,LF,BS
	.STRING	27.,'-
	.DOWN	3.,'!
	.EVEN
;
;	BRCLIR
;
GRAP26:	.WORD	GRAP7-.-2
	.POS	6.,13.
	.BYTE	SPACE,LF,BS
	.STRING	27.,SPACE
	.DOWN	3.,SPACE
	.EVEN
;
;	IRTODC
;
GRAP7:	.WORD	GRAP27-.-2
	.POS	13.,39.
	.DOWN	3.,'!
	.EVEN
;
;	IRCLDC
;
GRAP27:	.WORD	GRAP8-.-2
	.POS	13.,39.
	.DOWN	3.,SPACE
	.EVEN
;
;	IRTOPC
;
GRAP8:	.WORD	GRAP28-.-2
	.POS	13.,40.
	.BYTE	'!,LF,BS
	.STRING	21.,'-
	.BYTE	LF,BS,'!
	.EVEN
;
;	IRCLPC
;
GRAP28:	.WORD	GRAP9-.-2
	.POS	13.,40.
	.BYTE	SPACE,LF,BS
	.STRING	21.,SPACE
	.BYTE	LF,BS,SPACE
	.EVEN
;
;	PCTOAR
;
GRAP9:	.WORD	GRAP29-.-2
	.POS	15.,60.
	.UP	8.,'!
	.EVEN
;
;	PCCLAR
;
GRAP29:	.WORD	GRAP10-.-2
	.POS	15.,60.
	.UP	8.,SPACE
	.EVEN
;
;	ARTOME
;
GRAP10:	.WORD	GRAP30-.-2
	.POS	4.,60.
	.BYTE	'^,ESC,'A,BS
	.STRING	10.,'>
	.POS	4.,61.
	.ASCII	/ADDRESS->/
	.EVEN
;
;	ARCLME
;
GRAP30:	.WORD	GRAP11-.-2
	.POS	4.,60.
	.BYTE	SPACE,ESC,'A,BS
	.STRING	10.,SPACE
	.POS	4.,61.
	.STRING	9.,SPACE
	.EVEN
;
;	IRTOAR
;
GRAP11:	.WORD	GRAP31-.-2
	.POS	13.,40.
	.BYTE	'!,LF,BS
	.STRING	19.,'-
	.BYTE	BS
	.UP	7.,'!
	.EVEN
;
;	IRCLAR
;
GRAP31:	.WORD	GRAP12-.-2
	.POS	13.,40.
	.BYTE	SPACE,LF,BS
	.STRING	19.,SPACE
	.BYTE	BS
	.UP	7.,SPACE
	.EVEN
;
;	PCPLON
;
GRAP12:	.WORD	GRAP32-.-2
	.POS	17.,67.
	.BYTE	'-
	.DOWN	5.,'!
	.POS	21.,68.
	.LEF	5.,'-
	.POS	20.,60.
	.STRING	4.,'#
	.POS	22.,60.
	.STRING	4.,'#
	.POS	21.,60.
	.ASCII	/#+1+/
	.POS	21.,59.
	.LEF	2.,'-
	.UP	3.,'!
	.EVEN
;
;	PCCLON
;
GRAP32:	.WORD	GRAP13-.-2
	.POS	17.,67.
	.BYTE	SPACE
	.DOWN	5,SPACE
	.POS	19.,57.
	.STRING	13.,SPACE
	.POS	21.,57.
	.STRING	13.,SPACE
	.POS	20.,57.
	.STRING	13.,SPACE
	.POS	22.,60.
	.STRING	4.,SPACE
	.EVEN
;
;	METOBR
;
GRAP13:	.WORD	GRAP33-.-2
	.POS	1.,69.
	.LEF	5.,'<
	.POS	1.,64.
	.LEF	5.,'<
	.POS	1.,59.
	.LEF	5.,'<
	.POS	1.,54.
	.LEF	5.,'<
	.POS	1.,49.
	.LEF	5.,'<
	.POS	1.,44.
	.LEF	5.,'<
	.POS	1.,39.
	.LEF	5.,'<
	.POS	1.,34.
	.LEF	5.,'<
	.POS	1.,29.
	.LEF	5.,'<
	.POS	1.,24.
	.LEF	5.,'<
	.POS	1.,19.
	.LEF	5.,'<
	.POS	1.,14.
	.DOWN	2.,'V
	.EVEN
;
;	MECLBR
;
GRAP33:	GRAP14-.-2
	.POS	1.,69.
	.LEF	5.,SPACE
	.POS	1.,64.
	.LEF	5.,SPACE
	.POS	1.,59.
	.LEF	5.,SPACE
	.POS	1.,54.
	.LEF	5.,SPACE
	.POS	1.,49.
	.LEF	5.,SPACE
	.POS	1.,44.
	.LEF	5.,SPACE
	.POS	1.,39.
	.LEF	5.,SPACE
	.POS	1.,34.
	.LEF	5.,SPACE
	.POS	1.,29.
	.LEF	5.,SPACE
	.POS	1.,24.
	.LEF	5.,SPACE
	.POS	1.,19.
	.LEF	5.,SPACE
	.POS	1.,14.
	.DOWN	2.,SPACE
	.EVEN
;
;	MMREAD
;
GRAP14:	.WORD	GRAP34-.-2
	.POS	9.,63.
	.STRING	6.,'$
	.POS	10.,63.
	.ASCII	/MEMORY/
	.POS	11.,64.
	.ASCII	/READ/
	.POS	12.,63.
	.STRING	6.,'$
	.EVEN
;
;	MMCLAD
;
GRAP34:
GRAP35:	.WORD	GRAP15-.-2
	.POS	9.,63.
	.STRING	6.,SPACE
	.POS	10.,63.
	.STRING	6.,SPACE
	.POS	11.,63.
	.STRING	6.,SPACE
	.POS	12.,63.
	.STRING	6.,SPACE
	.EVEN
;
;	MMWRIT
;
GRAP15:	.WORD	GRAP16-.-2
	.POS	9.,63.
	.STRING	6.,'$
	.POS	10.,63.
	.ASCII	/MEMORY/
	.POS	11.,64.
	.ASCII	/WRITE/
	.POS	12.,63.
	.STRING	6.,'$
	.EVEN
;
;	ACCUCL
;
GRAP16:	.WORD	GRAP36-.-2
	.POS	7.,5.
	.STRING	12.,'0
	.POS	8.,5.
	.STRING	12.,'!
	.POS	9.,5.
	.STRING	12.,'!
	.POS	11.,5.
	.STRING	12.,'0
	.EVEN
;
;	ACCLCL
;
GRAP36:	.WORD	GRAP17-.-2
	.POS	7.,5.
	.STRING	12.,SPACE
	.POS	8.,5.
	.STRING	12.,SPACE
	.POS	9.,4.
	.ASCII	/ACCU/
	.STRING	10.,SPACE
	.EVEN
;
;	SERVIC
;
GRAP17:	.WORD	GRAP18-.-2
	.POS	21.,41.
	.ASCII	/SERVE/
	.EVEN
;
;	GOFETC
;
GRAP18:	.WORD	GRAP19-.-2
	.POS	21.,41.
	.ASCII	/FETCH/
	.EVEN
;
;	GOEXEC
;
GRAP19:	.WORD	GRAP20-.-2
	.POS	21.,41.
	.ASCII	/EXEC /
	.EVEN
;
;	EXEALU
;
GRAP20:	.WORD	GRAP37-.-2
	.POS	17.,13.
	.STRING	12.,'+
	.POS	19.,13.
	.STRING	4.,'+
	.POS	19.,21.
	.STRING	4.,'+
	.POS	17.,13.
	.STRING	12.,SPACE
	.POS	19.,13.
	.STRING	4.,SPACE
	.POS	19.,21.
	.STRING	4.,SPACE
	.EVEN
;
;	ALTOBR
;
GRAP37:	.WORD	GRAP38-.-2
	.POS	21.,19.
	.BYTE	'!,LF,BS
	.STRING	10.,'-
	.UP	15.,'!
	.LEF	14.,'-
	.UP	2.,'!
	.EVEN
;
;	ALCLBR
;
GRAP38:	.WORD	GRAP39-.-2
	.POS	21.,19.
	.BYTE	SPACE,LF,BS
	.STRING	10.,SPACE
	.UP	15.,SPACE
	.LEF	14.,SPACE
	.UP	2.,SPACE
	.EVEN
;
;	GOHALT
;
GRAP39:	.WORD	GRAP40-.-2
	.POS	22.,50.
	.ASCII	/HALT/
	.EVEN
;
;
;
GRAP40:	.WORD	GRAP41-.-2
	.POS	6.,13.
	.BYTE	'!,LF,BS
	.STRING	30.,'-
	.BYTE	LF
	.STRING	5.,'_
	.BYTE	LF
	.STRING	10.,'-
	.UP	2.,'!
	.EVEN
;
GRAP41:	.WORD	GRAP42-.-2
	.POS	6.,13.
	.BYTE	SPACE,LF,BS
	.STRING	30.,SPACE
	.BYTE	LF
	.STRING	5.,SPACE
	.BYTE	LF
	.STRING	10.,SPACE
	.UP	2.,SPACE
	.EVEN
;
GRAP42:	.WORD	GRAP43-.-2
	.POS	21.,19.
	.BYTE	'[
	.POS	21.,23.
	.BYTE	']
	.POS	22.,19.
	.ASCII	/<:::>/
	.POS	21.,19.
	.BYTE	SPACE
	.POS	21.,23.
	.BYTE	SPACE
	.POS	22.,19.
	.STRING	5,SPACE
	.EVEN
;
GRAP43:
;
; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
;	C O N V E R S A T I O N A L   M E S S A G E S 
; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
;
IMES1:	.WORD	IMES1A-.-2
	.BYTE	ESC,'[,'?,'2,'1	;ENTER VT52 MODE
	.BYTE	ESC,'H,ESC,'J	;HOME AND CLEAR SCREEN
	.POS	10.,33.
	.ASCII	/WELCOME TO THE/
	.POS	12.,29.
	.ASCII	/INTRODUCTION COMPUTER/
	.POS	14.,32.
	.ASCII	/FROM DEC EDUCATION/
	.POS	16.,28.
	.ASCII	/UTRECHT, THE NETHERLANDS/
	.EVEN
;
IMES1A:
IMES2:	.WORD	IMES3-.-2
	.POS	20.,1.
	.BYTE	ESC,'J		;CLEAR SCREEN
	.ASCII	/Load program (L), Execute (E), /
	.ASCII	/Help (H) or Quit (Q) ? :/
	.EVEN
;
IMES3:	.WORD	IMES4-.-2
	.POS	20.,1.
	.BYTE	ESC,'J
	.ASCII	/Do you want to change the way of executing?/
	.BYTE	CR,LF
	.ASCII	/  Yes (Y) or No (N) ? :/
	.EVEN
;
IMES4:	.WORD	IMES5-.-2
	.POS	20.,1.
	.BYTE	CR,LF
	.ASCII	/Time-pause choice : Nowait (N), /
	.ASCII	/Autostep (A) or Userstep (U) ? :/
	.EVEN
;
IMES5:	.WORD	IMES6-.-2
	.POS	20.,1.
	.BYTE	ESC,'J
	.ASCII	/Pause between instructions /
	.EVEN
;
IMES6:	.WORD	IMES7-.-2
	.POS	20.,1.
	.BYTE	ESC,'J
	.ASCII	/Pause between micro instructions/
	.EVEN
;
IMES7:	.WORD	IMES8-.-2
	.POS	20.,1.
	.BYTE	ESC,'J
	.ASCII	/Register read out Octal (O) /
	.ASCII	/or Binary (B) ? :/
	.EVEN
;
IMES8:	.WORD	IMES9-.-2
	.POS	20.,1.
	.CLIN
	.ASCII	/What is the load address of your program or data? :/
	.EVEN
;
IMES9:	.WORD	IMES10-.-2
	.POS	20.,1.
	.BYTE	ESC,'J
	.ASCII	/Are you satisfied with your answers? /
	.ASCII	/Yes (Y) or NO (N) ? :/
	.EVEN
;
IMES10:	.WORD	IMES11-.-2
	.POS	20.,1.
	.BYTE	ESC,'J
	.ASCII	/Please fill in the octal value of your program behind the address./
	.BYTE	CR,LF
	.ASCII	/If you have loaded the last value,then you can type: END/
	.BYTE	CR,LF
	.ASCII	/to end the loading process./
	.POS	24.,35.
	.EVEN
;
IMES11:	.WORD	IMES12-.-2
	.POS	24.,13.
	.ASCII	/Did you push a wrong key/
	.ASCII	# did you make a mistake (Y/N) ? :#
	.BYTE	ESC,'A
	.EVEN
;
IMES12:	.WORD	IMES13-.-2
	.POS	20.,1.
	.BYTE	ESC,'J
	.ASCII	/Starting address of your program? :/
	.EVEN
;
IMES13:	.WORD	IMES14-.-2
	.POS	20.,1.
	.BYTE	ESC,'J
	.ASCII	/First addres of virtual memory? :/
	.EVEN
;
IMES14:	.WORD	IMES15-.-2
	.BYTE	CR,LF
	.ASCII	/Number of ticks of 20msec, (OCTAL)? :/
	.EVEN
;
IMES15:	.WORD	IMES16-.-2
	.POS	22.,50.
	.ASCII	/HALT/
	.POS	24.,35.
	.ASCII	/Go on (G) or back to console (C)? :/
	.BYTE	ESC,'A
	.EVEN
;
IMES16:	.WORD	IMES17-.-2
	.POS	17.,41.
	.STRING	4.,'?
	.POS	23.,13.
	.ASCII	/ILLEGAL INSTRUCTION !!!!/
	.POS	24.,13.
	.STRING	65.,'?
	.BYTE	ESC,'A
	.EVEN
;
IMES17:	.WORD	IMES18-.-2
	.POS	24.,50.
	.ASCII	/Non existing memory address/
	.BYTE	ESC,'A
	.EVEN
;
IMES18:	.WORD	IMES19-.-2
	.BYTE	ESC,'H,ESC,'J	;CLEAN SCREEN.
	.POS	1.,21.
	.ASCII	/M E M O R Y   C O N T E N T S/
	.POS	1.,66.
	.ASCII	/#CONSOLE MODE#/
	.BYTE	CR,LF
	.REPT	7.
	.ASCII	/ ADDR CONT /
	.ENDR
	.EVEN
;
IMES19:	.WORD	IMES20-.-2
	.BYTE	CR,LF
	.ASCII	/Do you want to draw lines with delay?/
	.BYTE	CR,LF
	.ASCII	/Delay (D) or no delay (N) ? :/
	.EVEN
;
IMES20:	.WORD	IMES21-.-2
	.POS	20.,1.
	.BYTE	ESC,'J
	.ASCII	/Do you want subtitles during the run?/
	.BYTE	CR,LF
	.ASCII	/Yes (Y) or No (N) ? :/
	.EVEN
;
IMES21:	.WORD	IMES22-.-2
	.POS	20.,1.
	.BYTE	ESC,'J
	.ASCII	#Do you want data-flow lines drawn? (Y/N) ? :#
	.EVEN
;
IMES22:	.WORD	IMES23-.-2
	.BYTE	ESC,'H,ESC,'J
	.ASCII	/You are connected to the intro-computer./
	.BYTE	CR,LF
	.ASCII	/This is a minicomoputer, from which the hart is layed open/
	.BYTE	CR,LF
	.ASCII	/and made visible during the run. In executing your program /
	.ASCII	/it is possible/
	.BYTE	CR,LF
	.ASCII	/to follow the flow of data between memory and registers./
	.BYTE	CR,LF
	.ASCII	/The computer always works in one of the following states :/
	.BYTE	CR,LF
	.POS	6.,10.
	.ASCII	/1.:   console mode/
	.POS	7.,10.
	.ASCII	/2.:   run or execute mode/
	.BYTE	CR,LF
	.ASCII	/During console mode, it is possible to load the computer /
	.ASCII	/memory with your/
	.BYTE	CR,LF
	.ASCII	/program and data. When the loading process is ready, you can/
	.BYTE	CR,LF
	.ASCII	/execute your program. It is possible to make changes in/
	.BYTE	CR,LF
	.ASCII	/the way your program will be executed. The main memory of /
	.ASCII	/consists of/
	.BYTE	CR,LF
	.ASCII	/105 words. Only 21 words are shown during the execution /
	.ASCII	/of your program./
	.BYTE	CR,LF
	.ASCII	/You can say where to start these 21 words. /
	.ASCII	/it is also possible to choose/
	.BYTE	CR,LF
	.ASCII	/how the execution of your program can be delayed./
	.BYTE	CR,LF
	.ASCII	/Thereby is N: no delay, A: deleay with a number of stops of 20 msec,/
	.BYTE	CR,LF
	.ASCII	/and U: the computer will halt until you have understood what was /
	.ASCII	/happening./
	.BYTE	CR,LF
	.ASCII	/Then you can push the space-bar and the next action will take place./
	.BYTE	CR,LF
	.ASCII	/This is possible between the instructions and between the micro-instr./
	.BYTE	CR,LF
	.ASCII	/Memory organisation: 12 bit words./
	.POS	21.,13.
	.ASCII	/Instruction-set of computer : >>>/
	.POS	19.,47.
	.ASCII	/1XXX = ADD  6XXX = STRI /
	.POS	20.,47.
	.ASCII	/2XXX = ISZ  7001 = IAC  7440 = SIZ/
	.POS	21.,47.
	.ASCII	/3XXX = STR  7040 = CMA  7500 = SIM/
	.POS	22.,47.
	.ASCII	/4XXX = ADDI 7200 = CLA  7510 = SIP/
	.POS	23.,47.
	.ASCII	/5XXX = JMP  7402 = HLT/
	.POS	24.,47.
	.ASCII	/Push space-bar to continue/
	.BYTE	ESC,'A		;ONE UP.
	.EVEN
;
IMES23:	.WORD	IMES24-.-2
	.BYTE	ESC,'H,ESC,'J
	.POS	10.,35.
	.ASCII	/P O W E R/
	.POS	11.,37.
	.ASCII	/O F F/
	.EVEN
;
IMES24:	.WORD	IMES25-.-2
	.POS	21.,20.
	.ASCII	/ZERO/
	.EVEN
;
IMES25:	.WORD	IMES26-.-2
	.POS	21.,20.
	.ASCII	/POS/
	.EVEN
;
IMES26:	.WORD	IMES27-.-2
	.POS	21.,20.
	.ASCII	/NEG/
	.EVEN
;
IMES27:	.WORD	IMES28-.-2
	.POS	23.,52.
	.ASCII	/YES ! ! !/
	.EVEN
;
IMES28:	.WORD	IMES29-.-2
	.POS	23.,52.
	.ASCII	/NO/
	.EVEN
;
IMES29:	.WORD	IMES30-.-2
	.POS	24.,35.
	.EVEN
;
IMES30:	.WORD	IMES31-.-2
	.BYTE	ESC,'<
	.EVEN
;
IMES31:
;
;
; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
;
;	M I C R O   I N S T R U C T I O N
;		F I E L D
;
; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
;
MFETCH:	.WORD	GOFETC,IRCLDC,PCTOAR
	.WORD	ARTOME,MMREAD,METOBR
	.WORD	BRTOIR,PCCLAR,ARCLME
	.WORD	MMCLAD,MECLBR,BRCLIR
	.WORD	PCPLON,PCCLON,GOEXEC
	.BYTE	IRTODC
	.BYTE	201		;GO TO EXECUTE TABLE.
;
MEXTAB:	.WORD	MA1,MA2,MA3,MA4
	.WORD	MA5,MA6,MA7,MA8
	.WORD	MA9,MA10,MA11,MA12,MA13
;
MSERVC:	.BYTE	SERVIC
	.BYTE	200		;GO TO FETCH STATE.
	.WORD	MFETCH
;
;	ADD MICRO
MA1:	.WORD	IRTOAR,ARTOME,MMREAD
	.WORD	METOBR,ACTOAL,BRTOAL
	.WORD	EXEALU,ALTOAC,IRCLAR
	.WORD	ARCLME,MMCLAD,MECLBR
	.WORD	ACCLAL,BRCLAL
	.BYTE	ALCLAC
	.BYTE	202		;GO TO SERVICE STATE.
;
;	ISZ MICRO
MA2:	.WORD	IRTOAR,ARTOME,MMREAD
	.WORD	METOBR,BRTOAL,EXEALU
	.WORD	ALTOBR,MMCLAD,BRTOME
	.WORD	MMWRIT,IRCLAR,ARCLME
	.WORD	MMCLAD,BRCLME,BRCLAL
	.WORD	ALCLBR
	.BYTE	MUSKIP
	.BYTE	203		;SKIP CONDITION?
	.WORD	MSKIP		;SKIP ADDRESS MICRO
;NOTE : JUMP OVER IF NO SKIP CONDITION.
	.BYTE	ARCLME
	.BYTE	202		;GO TO SERVICE STATE.
MSKIP:	.WORD	PCPLON
	.BYTE	PCPLON
	.BYTE	202		;GO TO SERVICE STATE.
;
;	STR MICRO
MA3:	.WORD	IRTOAR,ARTOME,ACTOBR
	.WORD	BRTOME,MMWRIT,IRCLAR
	.WORD	ARCLME,ACCLBR,BRCLME
	.BYTE	MMCLIT
	.BYTE	200		;GO TO CLA MICRO.
	.WORD	MA7
;
;	JMP MICRO
MA4:	.WORD	IRTOPC
	.BYTE	IRCLPC
	.BYTE	202		;GO TO SERVICE STATE.
;
;	IAC MICRO
MA5:	.WORD	ACTOAL,EXEALU,ALTOAC
	.WORD	ACCLAL
	.BYTE	ALCLAC
	.BYTE	202		;GO TO SERVICE STATE.
;
;	CMA MICRO
MA6:	.BYTE	ALCLAC
	.BYTE	200		;CMA COMMON ROUTINE.
	.WORD	MA5
;
;	CLA MICRO
MA7:	.WORD	ACCUCL
	.BYTE	ACCLCL
	.BYTE	202		;GO TO SERVICE STATE.
;
;	HLT MICRO
MA8A:	.WORD	BRCLME,BRCLAR
	.WORD	ACCLBR,PCCLAR
	.WORD	ARCLME,IRCLAR
	.WORD	MMCLAD
MA8:	.BYTE	GOHALT
	.BYTE	204		;GO TO STOP STATE.
;
;	ADD INDIRECT MICRO
MA9:	.WORD	IRTOAR,ARTOME,MMREAD
	.WORD	METOBR,IRCLAR,ARCLME
	.WORD	MMCLAD,MECLBR,BRTOAR
	.WORD	ARTOME,MMREAD,BRCLAR
	.WORD	METOBR,ARCLME,MMCLAD
	.WORD	BRTOAL,ACTOAL,EXEALU
	.WORD	ALTOAC,MECLBR,BRCLAL
	.WORD	ACCLAL
	.BYTE	ALCLAC
	.BYTE	202		;GO TO SERVICE STATE.
;
;	STORE INDIRECT MICRO
MA10:	.WORD	IRTOAR,ARTOME,MMREAD
	.WORD	METOBR,IRCLAR,ARCLME
	.WORD	MMCLAD,MECLBR,BRTOAR
	.WORD	ARTOME,BRCLAR,ACTOBR
	.WORD	BRTOME,MMWRIT,ACCLBR
	.WORD	MMCLIT,BRCLME,BRCLAR
	.BYTE	ARCLME
	.BYTE	200		;GO TO CLA MICRO.
	.WORD	MA7
;
;	SKIP IF ZERO
MA11:
;
;	SKIP IF MINUS
MA12:
;
;	SKIP IF POSITIVE
MA13:	.BYTE	MUSKIP
	.BYTE	203
	.WORD	MSKIP
	.BYTE	IRCLDC
	.BYTE	202		;GO TO SERVICE STATE.
;
;	MICRO TABLES
;
MICTAB:	.WORD	GRAP1,GRAP2,GRAP3
	.WORD	GRAP3,GRAP5,GRAP6
	.WORD	GRAP7,GRAP8,GRAP9
	.WORD	GRAP10,GRAP11,GRAP12
	.WORD	GRAP13,GRAP14,GRAP15
	.WORD	GRAP16,GRAP17,GRAP18
	.WORD	GRAP19,GRAP20,GRAP21
	.WORD	GRAP22,GRAP23,GRAP24
	.WORD	GRAP25,GRAP26,GRAP27
	.WORD	GRAP28,GRAP29,GRAP30
	.WORD	GRAP31,GRAP32,GRAP33
	.WORD	GRAP34,GRAP35,GRAP36
	.WORD	GRAP37,GRAP38,GRAP39
	.WORD	GRAP40,GRAP41,GRAP42
;
COMTAB:	.WORD	MES1,MES2,MES3,MES4
	.WORD	MES5,MES6,MES7,MES8
	.WORD	MES9,MES10,MES11,MES12
	.WORD	MES13,MES14,MES15,MES16
	.WORD	MES17,MES18,MES19,MES20
	.REPT	16.
	.WORD	MESCL
	.ENDR
	.WORD	MES37,MESCL,MES39
	.WORD	MES40,MESCL,MES42
;
ACTTAB:	.WORD	ACT1,ACT2,ACT3,ACT4
	.WORD	ACT5,ACT6,ACT7,ACT8
	.WORD	ACT9,ACT10,ACT11,ACT12
	.WORD	ACT13,ACT14,ACT15,ACT16
	.WORD	ACT17,ACT18,ACT19,ACT20
	.REPT	16.
	.WORD	ACTNO
	.ENDR
	.WORD	ACT37,ACTNO,ACT39
	.WORD	ACT40,ACTNO,ACT42
;
; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
; INSTRUCTION TABLES
; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;
;
INSTAB:	.WORD	1000	;ADD	1
	.WORD	2000	;ISZ	2
	.WORD	3000	;STR	3
	.WORD	5000	;JMP	4
	.WORD	7001	;IAC	5
	.WORD	7040	;CMA	6
	.WORD	7200	;CLA	7
	.WORD	7402	;HLT	8
	.WORD	4000	;ADD I	9
	.WORD	6000	;STR I	10
	.WORD	7440	;SIZ	11
	.WORD	7500	;SIM	12
	.WORD	7510	;SIP	13
ITABE:				;END OF TABLE
;
;	EXECUTION TABLE FOR ALU
;
EXALTB:	.WORD	ACT201,ACT202,ACT203,ACT204
	.WORD	ACT205,ACT206,ACT207,ACT208
	.WORD	ACT209,ACT210,ACT211,ACT212
	.WORD	ACT213
;
;	GRAPHIC DECODER TABLE
;
INATAB:	.WORD	INST1,INST2,INST3,INST4
	.WORD	INST5,INST6,INST7,INST8
	.WORD	INST9,INST10,INST11,INST12,INST13
	.WORD	INSTL		;ILLEGAL
;
INST1:	.POS	17.,41.
	.ASCII	/ADD /
;
INST2:	.POS	17.,41.
	.ASCII	/ISZ /
;
INST3:	.POS	17.,41.
	.ASCII	/STR /
;
INST4:	.POS	17.,41.
	.ASCII	/JMP /
;
INST5:	.POS	17.,41.
	.ASCII	/IAC /
;
INST6:	.POS	17.,41.
	.ASCII	/CMA /
;
INST7:	.POS	17.,41.
	.ASCII	/CLA /
;
INST8:	.POS	17.,41.
	.ASCII	/HLT /
;
INST9:	.POS	17.,41.
	.ASCII	/ADDI/
;
INST10:	.POS	17.,41.
	.ASCII	/STRI/
;
INST11:	.POS	17.,41.
	.ASCII	/SIZ /
;
INST12:	.POS	17.,41.
	.ASCII	/SIM /
;
INST13:	.POS	17.,41.
	.ASCII	/SIP /
	.EVEN
;
INSTL:	.ASCII	/????/
;
;	INSTRUCTION INDEX WORD
;
IINDEX:	.WORD	0
;
;
;	CONDITION REGISTER
;
;	BIT 0 IS USED AND IS ZERO BIT
;	BIT 1 IS USED AND IS MINUS BIT
;
CONDZE:	.WORD	0
;
;	INSTRUCTION INDICATION
;
INTB:	.WORD	INT1,INT2,INT3,INT4
	.WORD	INT5,INT6,INT7,INT8
	.WORD	INT9,INT10,INT11,INT12,INT13
;
INT1:	.WORD	INT2-.-2
	.POS	23.,13.
	.ASCII	/ADD   add accu to memory/
	.EVEN
;
INT2:	.WORD	INT3-.-2
	.POS	23.,13.
	.ASCII	/ISZ   increment memory location, skip??/
	.EVEN
;
INT3:	.WORD	INT4-.-2
	.POS	23.,13.
	.ASCII	/STR   put accumulator value into memory/
	.EVEN
;
INT4:	.WORD	INT5-.-2
	.POS	23.,13.
	.ASCII	/JMP   jump to the given address/
	.EVEN
;
INT5:	.WORD	INT6-.-2
	.POS	23.,13.
	.ASCII	/IAC   increment the accumulator with one/
	.EVEN
;
INT6:	.WORD	INT7-.-2
	.POS	23.,13.
	.ASCII	/CMA   complement/
	.EVEN
;
INT7:	.WORD	INT8-.-2
	.POS	23.,13.
	.ASCII	/CLA   put value in accumulator to zero/
	.EVEN
;
INT8:	.WORD	INT9-.-2
	.POS	23.,13.
	.ASCII	/HLT   stop the computer/
	.EVEN
;
INT9:	.WORD	INT10-.-2
	.POS	23.,13.
	.ASCII	/ADDI   add with indirect address mode/
	.EVEN
;
INT10:	.WORD	INT11-.-2
	.POS	23.,13.
	.ASCII	/STRI   put accu valu into memory with indirect addressing mode/
	.EVEN
;
INT11:	.WORD	INT12-.-2
	.POS	23.,13.
	.ASCII	/SIZ   ZERO ? skip one instruction......./
	.EVEN
;
INT12:	.WORD	INT13-.-2
	.POS	23.,13.
	.ASCII	/SIM   NEG  ? skip one instruction......./
	.EVEN
;
INT13:	.WORD	INT14-.-2
	.POS	23.,13.
	.ASCII	/SIP   POS  ? skip one instruction......./
	.EVEN
;
INT14:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	I N T E R N A L   R E G I S T E R S 
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
IBR:	.WORD	0		;BUFFER REGISTER
IAC:	.WORD	0		;ACCUMULATOR
IAL:	.WORD	0		;ARITHMETIC UNIT OUTPUT
IALA:	.WORD	0		;A INPUT ARITHMETIC UNIT
IALB:	.WORD	0		;B INPUT ARITHMETIC UNIT
IIR:	.WORD	0		;INSTRUCTION REGISTER
IAR:	.WORD	0		;ADDRESS REGISTER
IPC:	.WORD	0		;PROGRAM COUNTER
IMEM:	.BLKW	200.		;MEMORY SPACE
IMEMVL:	.WORD	0		;LOWER BOUNDARY VISABLE MEMORY
IMEMVH:	.WORD	21.		;HIGHER BOUNDARY VISABLE MEMORY
OUDVL:	.WORD	0		;OLDEST MEMORY BOUNDARY
OUDVH:	.WORD	21.
OCBINR:	.WORD	0		;DISPLAY RGISTER MODE
				; 0 = OCTAL  1 = BINARY
IOSTAT:	.BLKW	4.		;IOSTATUS BLOCK
;
;	TIME / PAUSE MODE
;	0 = NOWAIT, FAST EXECUTION
;	1 = AUTO STEP, DELAYED WITH FIXED PAUSE
;	2 = USER STEP, STEPS ACCORDING TO THE USER
;
SEQMOD:	.WORD	1		;AUTO STEP PRESET FOR MICO INSTRUCTIONS
	.WORD	500		;PRESET WAITLOOP OF 20MSEC TICKS
ISQMOD:	.WORD	2		;USER STEP FOR INSTRUCTIONS
	.WORD	0
MESENB:	.WORD	1		;ENABLE MESSAGES
GRENB:	.WORD	1		;ENABLE GRAPHICS BY USER
GRQENB:	.WORD	0		;ENABLE DELAY FOR GRAPHICS BY MICRO-PROG.
GRQMOD:	.WORD	0		;DELAY MODE BY USER
	.WORD	1		;20 MSEC TICKS
	.BLKW	10.
GENBUF:	.BLKW	20.		;GENERAL BUFFER
AREA:	.WORD	0,0
TIME:	.WORD	0,0
XQUE:	.BLKW	10.
GENM1:	.POS	22.,50.
	.ASCII	/wait/
GENM2:	.POS	22.,50.
	.ASCII	/run /
BOUT:	.BLKB	3000
	.END	START		;END OF VERY LONG PROGRAM!!!
;
; TO ASSEMBLE INTO: .MAC CPU
; TO LINK INTRO: .LINK CPURO
;
;
;Deze text file geeft een kort overzicht weer van de instructie set
;van de 'intro' computer.
;
;Met dit programma (CPU.TSK) kan men een minicomputer simuleren.
;U kunt dus zien hoe deze van binnen werkt, zodat de werking van een
;computer wat meer begrijpelijker voor u wordt.
;
;Ook kan men zien hoe de signalen in het algemeen verlopen.
;
;Dit programma kent slechts 13 instructies.
;
;		Deze zijn:
;
;		1xxx ADD	add accu to memory
;		2xxx ISZ	increment memory location
;		3xxx STR	store accu in memory
;		4xxx ADDI	add with indirect mode
;		5xxx JMP	jump to location
;		6xxx STRI	store accu indirect in memory
;		7001 IAC	increment accu by one
;		7040 CMA	complement accu
;		7200 CLA	clear accu
;		7402 HLT	halt
;		7440 SIZ	skip if zero		(skip one instruction)
;		7500 SIM	skip if negative	(skip one instruction)
;		7510 SIP	skip if positive	(skip one instruction)
;
;De xxx geven het adres aan waarop de instructie moet worden uitgevoerd.
;
;Bij de indirect mode wordt de waarde weggeschreven op het adres dat
;aangewezen wordt door de inhoud van het adres welke zich in de
;instructie bevind (voor de kenners de deferred mode).
;
